// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com/laex/cg2d/model/ScreenModel.proto

#ifndef PROTOBUF_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto__INCLUDED
#define PROTOBUF_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace laex {
namespace cg2d {
namespace model {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

class CGScreenModel;
class CGJoint;
class CGDistanceJointDef;
class CGRevoluteJointDef;
class CGPrismaticJointDef;
class CGPulleyJointDef;
class CGFrictionJointDef;
class CGWeldJointDef;
class CGResourceFile;
class CGEntitySpritesheetItem;
class CGEntityAnimation;
class CGEntity;
class CGBounds;
class CGVector2;
class CGColor;
class CGBodyDef;
class CGFilter;
class CGFixtureDef;
class CGShape;
class CGLayer;
class CGScreenPreferences;
class CGScreenPreferences_CGDebugDrawPreferences;
class CGScreenPreferences_CGWorldPreferences;
class CGScreenPreferences_CGCardPreferences;

enum CGJointType {
  UNKNOWN = 1,
  REVOLUTE = 2,
  PRISMATIC = 3,
  DISTANCE = 4,
  PULLEY = 5,
  MOUSE = 6,
  GEAR = 7,
  WHEEL = 8,
  WELD = 9,
  FRICTION = 10,
  ROPE = 11
};
bool CGJointType_IsValid(int value);
const CGJointType CGJointType_MIN = UNKNOWN;
const CGJointType CGJointType_MAX = ROPE;
const int CGJointType_ARRAYSIZE = CGJointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CGJointType_descriptor();
inline const ::std::string& CGJointType_Name(CGJointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CGJointType_descriptor(), value);
}
inline bool CGJointType_Parse(
    const ::std::string& name, CGJointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CGJointType>(
    CGJointType_descriptor(), name, value);
}
enum CGEntityCollisionType {
  NONE = 0,
  BOX = 1,
  CIRCLE = 2,
  CUSTOM = 3
};
bool CGEntityCollisionType_IsValid(int value);
const CGEntityCollisionType CGEntityCollisionType_MIN = NONE;
const CGEntityCollisionType CGEntityCollisionType_MAX = CUSTOM;
const int CGEntityCollisionType_ARRAYSIZE = CGEntityCollisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CGEntityCollisionType_descriptor();
inline const ::std::string& CGEntityCollisionType_Name(CGEntityCollisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CGEntityCollisionType_descriptor(), value);
}
inline bool CGEntityCollisionType_Parse(
    const ::std::string& name, CGEntityCollisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CGEntityCollisionType>(
    CGEntityCollisionType_descriptor(), name, value);
}
enum CGBodyType {
  STATIC = 1,
  KINEMATIC = 2,
  DYNAMIC = 3
};
bool CGBodyType_IsValid(int value);
const CGBodyType CGBodyType_MIN = STATIC;
const CGBodyType CGBodyType_MAX = DYNAMIC;
const int CGBodyType_ARRAYSIZE = CGBodyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CGBodyType_descriptor();
inline const ::std::string& CGBodyType_Name(CGBodyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CGBodyType_descriptor(), value);
}
inline bool CGBodyType_Parse(
    const ::std::string& name, CGBodyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CGBodyType>(
    CGBodyType_descriptor(), name, value);
}
enum CGEditorShapeType {
  SIMPLE_SHAPE_CIRCLE = 1,
  SIMPLE_SHAPE_BOX = 2,
  SIMPLE_SHAPE_HEDGE = 3,
  SIMPLE_SHAPE_VEDGE = 4,
  BACKGROUND_SHAPE = 5,
  ENTITY_SHAPE = 6
};
bool CGEditorShapeType_IsValid(int value);
const CGEditorShapeType CGEditorShapeType_MIN = SIMPLE_SHAPE_CIRCLE;
const CGEditorShapeType CGEditorShapeType_MAX = ENTITY_SHAPE;
const int CGEditorShapeType_ARRAYSIZE = CGEditorShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CGEditorShapeType_descriptor();
inline const ::std::string& CGEditorShapeType_Name(CGEditorShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CGEditorShapeType_descriptor(), value);
}
inline bool CGEditorShapeType_Parse(
    const ::std::string& name, CGEditorShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CGEditorShapeType>(
    CGEditorShapeType_descriptor(), name, value);
}
// ===================================================================

class CGScreenModel : public ::google::protobuf::Message {
 public:
  CGScreenModel();
  virtual ~CGScreenModel();

  CGScreenModel(const CGScreenModel& from);

  inline CGScreenModel& operator=(const CGScreenModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGScreenModel& default_instance();

  void Swap(CGScreenModel* other);

  // implements Message ----------------------------------------------

  CGScreenModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGScreenModel& from);
  void MergeFrom(const CGScreenModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.laex.cg2d.model.CGScreenPreferences screenPrefs = 1;
  inline bool has_screenprefs() const;
  inline void clear_screenprefs();
  static const int kScreenPrefsFieldNumber = 1;
  inline const ::com::laex::cg2d::model::CGScreenPreferences& screenprefs() const;
  inline ::com::laex::cg2d::model::CGScreenPreferences* mutable_screenprefs();
  inline ::com::laex::cg2d::model::CGScreenPreferences* release_screenprefs();
  inline void set_allocated_screenprefs(::com::laex::cg2d::model::CGScreenPreferences* screenprefs);

  // repeated .com.laex.cg2d.model.CGLayer layers = 2;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 2;
  inline const ::com::laex::cg2d::model::CGLayer& layers(int index) const;
  inline ::com::laex::cg2d::model::CGLayer* mutable_layers(int index);
  inline ::com::laex::cg2d::model::CGLayer* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGLayer >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGLayer >*
      mutable_layers();

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGScreenModel)
 private:
  inline void set_has_screenprefs();
  inline void clear_has_screenprefs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::laex::cg2d::model::CGScreenPreferences* screenprefs_;
  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGLayer > layers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGScreenModel* default_instance_;
};
// -------------------------------------------------------------------

class CGJoint : public ::google::protobuf::Message {
 public:
  CGJoint();
  virtual ~CGJoint();

  CGJoint(const CGJoint& from);

  inline CGJoint& operator=(const CGJoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGJoint& default_instance();

  void Swap(CGJoint* other);

  // implements Message ----------------------------------------------

  CGJoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGJoint& from);
  void MergeFrom(const CGJoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sourceShapeId = 1;
  inline bool has_sourceshapeid() const;
  inline void clear_sourceshapeid();
  static const int kSourceShapeIdFieldNumber = 1;
  inline const ::std::string& sourceshapeid() const;
  inline void set_sourceshapeid(const ::std::string& value);
  inline void set_sourceshapeid(const char* value);
  inline void set_sourceshapeid(const char* value, size_t size);
  inline ::std::string* mutable_sourceshapeid();
  inline ::std::string* release_sourceshapeid();
  inline void set_allocated_sourceshapeid(::std::string* sourceshapeid);

  // optional string targetShapeId = 2;
  inline bool has_targetshapeid() const;
  inline void clear_targetshapeid();
  static const int kTargetShapeIdFieldNumber = 2;
  inline const ::std::string& targetshapeid() const;
  inline void set_targetshapeid(const ::std::string& value);
  inline void set_targetshapeid(const char* value);
  inline void set_targetshapeid(const char* value, size_t size);
  inline ::std::string* mutable_targetshapeid();
  inline ::std::string* release_targetshapeid();
  inline void set_allocated_targetshapeid(::std::string* targetshapeid);

  // optional .com.laex.cg2d.model.CGJointType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::com::laex::cg2d::model::CGJointType type() const;
  inline void set_type(::com::laex::cg2d::model::CGJointType value);

  // optional .com.laex.cg2d.model.CGDistanceJointDef distanceJointDef = 5;
  inline bool has_distancejointdef() const;
  inline void clear_distancejointdef();
  static const int kDistanceJointDefFieldNumber = 5;
  inline const ::com::laex::cg2d::model::CGDistanceJointDef& distancejointdef() const;
  inline ::com::laex::cg2d::model::CGDistanceJointDef* mutable_distancejointdef();
  inline ::com::laex::cg2d::model::CGDistanceJointDef* release_distancejointdef();
  inline void set_allocated_distancejointdef(::com::laex::cg2d::model::CGDistanceJointDef* distancejointdef);

  // optional .com.laex.cg2d.model.CGRevoluteJointDef revoluteJointDef = 6;
  inline bool has_revolutejointdef() const;
  inline void clear_revolutejointdef();
  static const int kRevoluteJointDefFieldNumber = 6;
  inline const ::com::laex::cg2d::model::CGRevoluteJointDef& revolutejointdef() const;
  inline ::com::laex::cg2d::model::CGRevoluteJointDef* mutable_revolutejointdef();
  inline ::com::laex::cg2d::model::CGRevoluteJointDef* release_revolutejointdef();
  inline void set_allocated_revolutejointdef(::com::laex::cg2d::model::CGRevoluteJointDef* revolutejointdef);

  // optional .com.laex.cg2d.model.CGPrismaticJointDef prismaticJointDef = 7;
  inline bool has_prismaticjointdef() const;
  inline void clear_prismaticjointdef();
  static const int kPrismaticJointDefFieldNumber = 7;
  inline const ::com::laex::cg2d::model::CGPrismaticJointDef& prismaticjointdef() const;
  inline ::com::laex::cg2d::model::CGPrismaticJointDef* mutable_prismaticjointdef();
  inline ::com::laex::cg2d::model::CGPrismaticJointDef* release_prismaticjointdef();
  inline void set_allocated_prismaticjointdef(::com::laex::cg2d::model::CGPrismaticJointDef* prismaticjointdef);

  // optional .com.laex.cg2d.model.CGPulleyJointDef pulleyJointDef = 8;
  inline bool has_pulleyjointdef() const;
  inline void clear_pulleyjointdef();
  static const int kPulleyJointDefFieldNumber = 8;
  inline const ::com::laex::cg2d::model::CGPulleyJointDef& pulleyjointdef() const;
  inline ::com::laex::cg2d::model::CGPulleyJointDef* mutable_pulleyjointdef();
  inline ::com::laex::cg2d::model::CGPulleyJointDef* release_pulleyjointdef();
  inline void set_allocated_pulleyjointdef(::com::laex::cg2d::model::CGPulleyJointDef* pulleyjointdef);

  // optional .com.laex.cg2d.model.CGFrictionJointDef frictionJointDef = 9;
  inline bool has_frictionjointdef() const;
  inline void clear_frictionjointdef();
  static const int kFrictionJointDefFieldNumber = 9;
  inline const ::com::laex::cg2d::model::CGFrictionJointDef& frictionjointdef() const;
  inline ::com::laex::cg2d::model::CGFrictionJointDef* mutable_frictionjointdef();
  inline ::com::laex::cg2d::model::CGFrictionJointDef* release_frictionjointdef();
  inline void set_allocated_frictionjointdef(::com::laex::cg2d::model::CGFrictionJointDef* frictionjointdef);

  // optional .com.laex.cg2d.model.CGWeldJointDef weldJointDef = 10;
  inline bool has_weldjointdef() const;
  inline void clear_weldjointdef();
  static const int kWeldJointDefFieldNumber = 10;
  inline const ::com::laex::cg2d::model::CGWeldJointDef& weldjointdef() const;
  inline ::com::laex::cg2d::model::CGWeldJointDef* mutable_weldjointdef();
  inline ::com::laex::cg2d::model::CGWeldJointDef* release_weldjointdef();
  inline void set_allocated_weldjointdef(::com::laex::cg2d::model::CGWeldJointDef* weldjointdef);

  // optional .com.laex.cg2d.model.CGVector2 localAnchorA = 11;
  inline bool has_localanchora() const;
  inline void clear_localanchora();
  static const int kLocalAnchorAFieldNumber = 11;
  inline const ::com::laex::cg2d::model::CGVector2& localanchora() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_localanchora();
  inline ::com::laex::cg2d::model::CGVector2* release_localanchora();
  inline void set_allocated_localanchora(::com::laex::cg2d::model::CGVector2* localanchora);

  // optional .com.laex.cg2d.model.CGVector2 localAnchorB = 12;
  inline bool has_localanchorb() const;
  inline void clear_localanchorb();
  static const int kLocalAnchorBFieldNumber = 12;
  inline const ::com::laex::cg2d::model::CGVector2& localanchorb() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_localanchorb();
  inline ::com::laex::cg2d::model::CGVector2* release_localanchorb();
  inline void set_allocated_localanchorb(::com::laex::cg2d::model::CGVector2* localanchorb);

  // optional bool useLocalAnchors = 13;
  inline bool has_uselocalanchors() const;
  inline void clear_uselocalanchors();
  static const int kUseLocalAnchorsFieldNumber = 13;
  inline bool uselocalanchors() const;
  inline void set_uselocalanchors(bool value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGJoint)
 private:
  inline void set_has_sourceshapeid();
  inline void clear_has_sourceshapeid();
  inline void set_has_targetshapeid();
  inline void clear_has_targetshapeid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_distancejointdef();
  inline void clear_has_distancejointdef();
  inline void set_has_revolutejointdef();
  inline void clear_has_revolutejointdef();
  inline void set_has_prismaticjointdef();
  inline void clear_has_prismaticjointdef();
  inline void set_has_pulleyjointdef();
  inline void clear_has_pulleyjointdef();
  inline void set_has_frictionjointdef();
  inline void clear_has_frictionjointdef();
  inline void set_has_weldjointdef();
  inline void clear_has_weldjointdef();
  inline void set_has_localanchora();
  inline void clear_has_localanchora();
  inline void set_has_localanchorb();
  inline void clear_has_localanchorb();
  inline void set_has_uselocalanchors();
  inline void clear_has_uselocalanchors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sourceshapeid_;
  ::std::string* targetshapeid_;
  ::com::laex::cg2d::model::CGDistanceJointDef* distancejointdef_;
  ::com::laex::cg2d::model::CGRevoluteJointDef* revolutejointdef_;
  ::com::laex::cg2d::model::CGPrismaticJointDef* prismaticjointdef_;
  ::com::laex::cg2d::model::CGPulleyJointDef* pulleyjointdef_;
  int type_;
  bool uselocalanchors_;
  ::com::laex::cg2d::model::CGFrictionJointDef* frictionjointdef_;
  ::com::laex::cg2d::model::CGWeldJointDef* weldjointdef_;
  ::com::laex::cg2d::model::CGVector2* localanchora_;
  ::com::laex::cg2d::model::CGVector2* localanchorb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGJoint* default_instance_;
};
// -------------------------------------------------------------------

class CGDistanceJointDef : public ::google::protobuf::Message {
 public:
  CGDistanceJointDef();
  virtual ~CGDistanceJointDef();

  CGDistanceJointDef(const CGDistanceJointDef& from);

  inline CGDistanceJointDef& operator=(const CGDistanceJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGDistanceJointDef& default_instance();

  void Swap(CGDistanceJointDef* other);

  // implements Message ----------------------------------------------

  CGDistanceJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGDistanceJointDef& from);
  void MergeFrom(const CGDistanceJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional float freqencyHz = 2;
  inline bool has_freqencyhz() const;
  inline void clear_freqencyhz();
  static const int kFreqencyHzFieldNumber = 2;
  inline float freqencyhz() const;
  inline void set_freqencyhz(float value);

  // optional float dampingRatio = 3;
  inline bool has_dampingratio() const;
  inline void clear_dampingratio();
  static const int kDampingRatioFieldNumber = 3;
  inline float dampingratio() const;
  inline void set_dampingratio(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGDistanceJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_freqencyhz();
  inline void clear_has_freqencyhz();
  inline void set_has_dampingratio();
  inline void clear_has_dampingratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool collideconnected_;
  float freqencyhz_;
  float dampingratio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGDistanceJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGRevoluteJointDef : public ::google::protobuf::Message {
 public:
  CGRevoluteJointDef();
  virtual ~CGRevoluteJointDef();

  CGRevoluteJointDef(const CGRevoluteJointDef& from);

  inline CGRevoluteJointDef& operator=(const CGRevoluteJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGRevoluteJointDef& default_instance();

  void Swap(CGRevoluteJointDef* other);

  // implements Message ----------------------------------------------

  CGRevoluteJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGRevoluteJointDef& from);
  void MergeFrom(const CGRevoluteJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional float referenceAngle = 2;
  inline bool has_referenceangle() const;
  inline void clear_referenceangle();
  static const int kReferenceAngleFieldNumber = 2;
  inline float referenceangle() const;
  inline void set_referenceangle(float value);

  // optional bool enableLimit = 3;
  inline bool has_enablelimit() const;
  inline void clear_enablelimit();
  static const int kEnableLimitFieldNumber = 3;
  inline bool enablelimit() const;
  inline void set_enablelimit(bool value);

  // optional float lowerAngle = 4;
  inline bool has_lowerangle() const;
  inline void clear_lowerangle();
  static const int kLowerAngleFieldNumber = 4;
  inline float lowerangle() const;
  inline void set_lowerangle(float value);

  // optional float upperAngle = 5;
  inline bool has_upperangle() const;
  inline void clear_upperangle();
  static const int kUpperAngleFieldNumber = 5;
  inline float upperangle() const;
  inline void set_upperangle(float value);

  // optional bool enableMotor = 6;
  inline bool has_enablemotor() const;
  inline void clear_enablemotor();
  static const int kEnableMotorFieldNumber = 6;
  inline bool enablemotor() const;
  inline void set_enablemotor(bool value);

  // optional float motorSpeed = 7;
  inline bool has_motorspeed() const;
  inline void clear_motorspeed();
  static const int kMotorSpeedFieldNumber = 7;
  inline float motorspeed() const;
  inline void set_motorspeed(float value);

  // optional float maxMotorTorque = 8;
  inline bool has_maxmotortorque() const;
  inline void clear_maxmotortorque();
  static const int kMaxMotorTorqueFieldNumber = 8;
  inline float maxmotortorque() const;
  inline void set_maxmotortorque(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGRevoluteJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_referenceangle();
  inline void clear_has_referenceangle();
  inline void set_has_enablelimit();
  inline void clear_has_enablelimit();
  inline void set_has_lowerangle();
  inline void clear_has_lowerangle();
  inline void set_has_upperangle();
  inline void clear_has_upperangle();
  inline void set_has_enablemotor();
  inline void clear_has_enablemotor();
  inline void set_has_motorspeed();
  inline void clear_has_motorspeed();
  inline void set_has_maxmotortorque();
  inline void clear_has_maxmotortorque();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float referenceangle_;
  bool collideconnected_;
  bool enablelimit_;
  bool enablemotor_;
  float lowerangle_;
  float upperangle_;
  float motorspeed_;
  float maxmotortorque_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGRevoluteJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGPrismaticJointDef : public ::google::protobuf::Message {
 public:
  CGPrismaticJointDef();
  virtual ~CGPrismaticJointDef();

  CGPrismaticJointDef(const CGPrismaticJointDef& from);

  inline CGPrismaticJointDef& operator=(const CGPrismaticJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGPrismaticJointDef& default_instance();

  void Swap(CGPrismaticJointDef* other);

  // implements Message ----------------------------------------------

  CGPrismaticJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGPrismaticJointDef& from);
  void MergeFrom(const CGPrismaticJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional .com.laex.cg2d.model.CGVector2 anchor = 2;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 2;
  inline const ::com::laex::cg2d::model::CGVector2& anchor() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_anchor();
  inline ::com::laex::cg2d::model::CGVector2* release_anchor();
  inline void set_allocated_anchor(::com::laex::cg2d::model::CGVector2* anchor);

  // optional .com.laex.cg2d.model.CGVector2 axis = 3;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 3;
  inline const ::com::laex::cg2d::model::CGVector2& axis() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_axis();
  inline ::com::laex::cg2d::model::CGVector2* release_axis();
  inline void set_allocated_axis(::com::laex::cg2d::model::CGVector2* axis);

  // optional float referenceAngle = 5;
  inline bool has_referenceangle() const;
  inline void clear_referenceangle();
  static const int kReferenceAngleFieldNumber = 5;
  inline float referenceangle() const;
  inline void set_referenceangle(float value);

  // optional bool enableLimit = 6;
  inline bool has_enablelimit() const;
  inline void clear_enablelimit();
  static const int kEnableLimitFieldNumber = 6;
  inline bool enablelimit() const;
  inline void set_enablelimit(bool value);

  // optional float lowerTranslation = 7;
  inline bool has_lowertranslation() const;
  inline void clear_lowertranslation();
  static const int kLowerTranslationFieldNumber = 7;
  inline float lowertranslation() const;
  inline void set_lowertranslation(float value);

  // optional float upperTranslation = 8;
  inline bool has_uppertranslation() const;
  inline void clear_uppertranslation();
  static const int kUpperTranslationFieldNumber = 8;
  inline float uppertranslation() const;
  inline void set_uppertranslation(float value);

  // optional bool enableMotor = 9;
  inline bool has_enablemotor() const;
  inline void clear_enablemotor();
  static const int kEnableMotorFieldNumber = 9;
  inline bool enablemotor() const;
  inline void set_enablemotor(bool value);

  // optional float maxMotorForce = 10;
  inline bool has_maxmotorforce() const;
  inline void clear_maxmotorforce();
  static const int kMaxMotorForceFieldNumber = 10;
  inline float maxmotorforce() const;
  inline void set_maxmotorforce(float value);

  // optional float motorSpeed = 11;
  inline bool has_motorspeed() const;
  inline void clear_motorspeed();
  static const int kMotorSpeedFieldNumber = 11;
  inline float motorspeed() const;
  inline void set_motorspeed(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGPrismaticJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_referenceangle();
  inline void clear_has_referenceangle();
  inline void set_has_enablelimit();
  inline void clear_has_enablelimit();
  inline void set_has_lowertranslation();
  inline void clear_has_lowertranslation();
  inline void set_has_uppertranslation();
  inline void clear_has_uppertranslation();
  inline void set_has_enablemotor();
  inline void clear_has_enablemotor();
  inline void set_has_maxmotorforce();
  inline void clear_has_maxmotorforce();
  inline void set_has_motorspeed();
  inline void clear_has_motorspeed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::laex::cg2d::model::CGVector2* anchor_;
  ::com::laex::cg2d::model::CGVector2* axis_;
  float referenceangle_;
  bool collideconnected_;
  bool enablelimit_;
  bool enablemotor_;
  float lowertranslation_;
  float uppertranslation_;
  float maxmotorforce_;
  float motorspeed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGPrismaticJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGPulleyJointDef : public ::google::protobuf::Message {
 public:
  CGPulleyJointDef();
  virtual ~CGPulleyJointDef();

  CGPulleyJointDef(const CGPulleyJointDef& from);

  inline CGPulleyJointDef& operator=(const CGPulleyJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGPulleyJointDef& default_instance();

  void Swap(CGPulleyJointDef* other);

  // implements Message ----------------------------------------------

  CGPulleyJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGPulleyJointDef& from);
  void MergeFrom(const CGPulleyJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional .com.laex.cg2d.model.CGVector2 groundAnchorA = 2;
  inline bool has_groundanchora() const;
  inline void clear_groundanchora();
  static const int kGroundAnchorAFieldNumber = 2;
  inline const ::com::laex::cg2d::model::CGVector2& groundanchora() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_groundanchora();
  inline ::com::laex::cg2d::model::CGVector2* release_groundanchora();
  inline void set_allocated_groundanchora(::com::laex::cg2d::model::CGVector2* groundanchora);

  // optional .com.laex.cg2d.model.CGVector2 groundAnchorB = 3;
  inline bool has_groundanchorb() const;
  inline void clear_groundanchorb();
  static const int kGroundAnchorBFieldNumber = 3;
  inline const ::com::laex::cg2d::model::CGVector2& groundanchorb() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_groundanchorb();
  inline ::com::laex::cg2d::model::CGVector2* release_groundanchorb();
  inline void set_allocated_groundanchorb(::com::laex::cg2d::model::CGVector2* groundanchorb);

  // optional float ratio = 4;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 4;
  inline float ratio() const;
  inline void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGPulleyJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_groundanchora();
  inline void clear_has_groundanchora();
  inline void set_has_groundanchorb();
  inline void clear_has_groundanchorb();
  inline void set_has_ratio();
  inline void clear_has_ratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::laex::cg2d::model::CGVector2* groundanchora_;
  bool collideconnected_;
  float ratio_;
  ::com::laex::cg2d::model::CGVector2* groundanchorb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGPulleyJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGFrictionJointDef : public ::google::protobuf::Message {
 public:
  CGFrictionJointDef();
  virtual ~CGFrictionJointDef();

  CGFrictionJointDef(const CGFrictionJointDef& from);

  inline CGFrictionJointDef& operator=(const CGFrictionJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGFrictionJointDef& default_instance();

  void Swap(CGFrictionJointDef* other);

  // implements Message ----------------------------------------------

  CGFrictionJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGFrictionJointDef& from);
  void MergeFrom(const CGFrictionJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional float maxForce = 2;
  inline bool has_maxforce() const;
  inline void clear_maxforce();
  static const int kMaxForceFieldNumber = 2;
  inline float maxforce() const;
  inline void set_maxforce(float value);

  // optional float maxTorque = 3;
  inline bool has_maxtorque() const;
  inline void clear_maxtorque();
  static const int kMaxTorqueFieldNumber = 3;
  inline float maxtorque() const;
  inline void set_maxtorque(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGFrictionJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_maxforce();
  inline void clear_has_maxforce();
  inline void set_has_maxtorque();
  inline void clear_has_maxtorque();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool collideconnected_;
  float maxforce_;
  float maxtorque_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGFrictionJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGWeldJointDef : public ::google::protobuf::Message {
 public:
  CGWeldJointDef();
  virtual ~CGWeldJointDef();

  CGWeldJointDef(const CGWeldJointDef& from);

  inline CGWeldJointDef& operator=(const CGWeldJointDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGWeldJointDef& default_instance();

  void Swap(CGWeldJointDef* other);

  // implements Message ----------------------------------------------

  CGWeldJointDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGWeldJointDef& from);
  void MergeFrom(const CGWeldJointDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool collideConnected = 1;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 1;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGWeldJointDef)
 private:
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool collideconnected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGWeldJointDef* default_instance_;
};
// -------------------------------------------------------------------

class CGResourceFile : public ::google::protobuf::Message {
 public:
  CGResourceFile();
  virtual ~CGResourceFile();

  CGResourceFile(const CGResourceFile& from);

  inline CGResourceFile& operator=(const CGResourceFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGResourceFile& default_instance();

  void Swap(CGResourceFile* other);

  // implements Message ----------------------------------------------

  CGResourceFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGResourceFile& from);
  void MergeFrom(const CGResourceFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string resourceFile = 1;
  inline bool has_resourcefile() const;
  inline void clear_resourcefile();
  static const int kResourceFileFieldNumber = 1;
  inline const ::std::string& resourcefile() const;
  inline void set_resourcefile(const ::std::string& value);
  inline void set_resourcefile(const char* value);
  inline void set_resourcefile(const char* value, size_t size);
  inline ::std::string* mutable_resourcefile();
  inline ::std::string* release_resourcefile();
  inline void set_allocated_resourcefile(::std::string* resourcefile);

  // optional string resourceFileAbsolute = 2;
  inline bool has_resourcefileabsolute() const;
  inline void clear_resourcefileabsolute();
  static const int kResourceFileAbsoluteFieldNumber = 2;
  inline const ::std::string& resourcefileabsolute() const;
  inline void set_resourcefileabsolute(const ::std::string& value);
  inline void set_resourcefileabsolute(const char* value);
  inline void set_resourcefileabsolute(const char* value, size_t size);
  inline ::std::string* mutable_resourcefileabsolute();
  inline ::std::string* release_resourcefileabsolute();
  inline void set_allocated_resourcefileabsolute(::std::string* resourcefileabsolute);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGResourceFile)
 private:
  inline void set_has_resourcefile();
  inline void clear_has_resourcefile();
  inline void set_has_resourcefileabsolute();
  inline void clear_has_resourcefileabsolute();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* resourcefile_;
  ::std::string* resourcefileabsolute_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGResourceFile* default_instance_;
};
// -------------------------------------------------------------------

class CGEntitySpritesheetItem : public ::google::protobuf::Message {
 public:
  CGEntitySpritesheetItem();
  virtual ~CGEntitySpritesheetItem();

  CGEntitySpritesheetItem(const CGEntitySpritesheetItem& from);

  inline CGEntitySpritesheetItem& operator=(const CGEntitySpritesheetItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGEntitySpritesheetItem& default_instance();

  void Swap(CGEntitySpritesheetItem* other);

  // implements Message ----------------------------------------------

  CGEntitySpritesheetItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGEntitySpritesheetItem& from);
  void MergeFrom(const CGEntitySpritesheetItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.laex.cg2d.model.CGBounds extractBounds = 1;
  inline bool has_extractbounds() const;
  inline void clear_extractbounds();
  static const int kExtractBoundsFieldNumber = 1;
  inline const ::com::laex::cg2d::model::CGBounds& extractbounds() const;
  inline ::com::laex::cg2d::model::CGBounds* mutable_extractbounds();
  inline ::com::laex::cg2d::model::CGBounds* release_extractbounds();
  inline void set_allocated_extractbounds(::com::laex::cg2d::model::CGBounds* extractbounds);

  // optional int32 frameIndex = 2;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGEntitySpritesheetItem)
 private:
  inline void set_has_extractbounds();
  inline void clear_has_extractbounds();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::laex::cg2d::model::CGBounds* extractbounds_;
  ::google::protobuf::int32 frameindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGEntitySpritesheetItem* default_instance_;
};
// -------------------------------------------------------------------

class CGEntityAnimation : public ::google::protobuf::Message {
 public:
  CGEntityAnimation();
  virtual ~CGEntityAnimation();

  CGEntityAnimation(const CGEntityAnimation& from);

  inline CGEntityAnimation& operator=(const CGEntityAnimation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGEntityAnimation& default_instance();

  void Swap(CGEntityAnimation* other);

  // implements Message ----------------------------------------------

  CGEntityAnimation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGEntityAnimation& from);
  void MergeFrom(const CGEntityAnimation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string animationName = 1;
  inline bool has_animationname() const;
  inline void clear_animationname();
  static const int kAnimationNameFieldNumber = 1;
  inline const ::std::string& animationname() const;
  inline void set_animationname(const ::std::string& value);
  inline void set_animationname(const char* value);
  inline void set_animationname(const char* value, size_t size);
  inline ::std::string* mutable_animationname();
  inline ::std::string* release_animationname();
  inline void set_allocated_animationname(::std::string* animationname);

  // optional float animationDuration = 2;
  inline bool has_animationduration() const;
  inline void clear_animationduration();
  static const int kAnimationDurationFieldNumber = 2;
  inline float animationduration() const;
  inline void set_animationduration(float value);

  // optional bool defaultAnimation = 3;
  inline bool has_defaultanimation() const;
  inline void clear_defaultanimation();
  static const int kDefaultAnimationFieldNumber = 3;
  inline bool defaultanimation() const;
  inline void set_defaultanimation(bool value);

  // optional .com.laex.cg2d.model.CGEntityCollisionType collisionType = 4;
  inline bool has_collisiontype() const;
  inline void clear_collisiontype();
  static const int kCollisionTypeFieldNumber = 4;
  inline ::com::laex::cg2d::model::CGEntityCollisionType collisiontype() const;
  inline void set_collisiontype(::com::laex::cg2d::model::CGEntityCollisionType value);

  // optional .com.laex.cg2d.model.CGResourceFile spritesheetFile = 5;
  inline bool has_spritesheetfile() const;
  inline void clear_spritesheetfile();
  static const int kSpritesheetFileFieldNumber = 5;
  inline const ::com::laex::cg2d::model::CGResourceFile& spritesheetfile() const;
  inline ::com::laex::cg2d::model::CGResourceFile* mutable_spritesheetfile();
  inline ::com::laex::cg2d::model::CGResourceFile* release_spritesheetfile();
  inline void set_allocated_spritesheetfile(::com::laex::cg2d::model::CGResourceFile* spritesheetfile);

  // optional .com.laex.cg2d.model.CGResourceFile spritesheetJsonFile = 6;
  inline bool has_spritesheetjsonfile() const;
  inline void clear_spritesheetjsonfile();
  static const int kSpritesheetJsonFileFieldNumber = 6;
  inline const ::com::laex::cg2d::model::CGResourceFile& spritesheetjsonfile() const;
  inline ::com::laex::cg2d::model::CGResourceFile* mutable_spritesheetjsonfile();
  inline ::com::laex::cg2d::model::CGResourceFile* release_spritesheetjsonfile();
  inline void set_allocated_spritesheetjsonfile(::com::laex::cg2d::model::CGResourceFile* spritesheetjsonfile);

  // optional .com.laex.cg2d.model.CGResourceFile fixtureFile = 7;
  inline bool has_fixturefile() const;
  inline void clear_fixturefile();
  static const int kFixtureFileFieldNumber = 7;
  inline const ::com::laex::cg2d::model::CGResourceFile& fixturefile() const;
  inline ::com::laex::cg2d::model::CGResourceFile* mutable_fixturefile();
  inline ::com::laex::cg2d::model::CGResourceFile* release_fixturefile();
  inline void set_allocated_fixturefile(::com::laex::cg2d::model::CGResourceFile* fixturefile);

  // repeated .com.laex.cg2d.model.CGVector2 vertices = 8;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 8;
  inline const ::com::laex::cg2d::model::CGVector2& vertices(int index) const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_vertices(int index);
  inline ::com::laex::cg2d::model::CGVector2* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGVector2 >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGVector2 >*
      mutable_vertices();

  // repeated .com.laex.cg2d.model.CGEntitySpritesheetItem spritesheetItems = 9;
  inline int spritesheetitems_size() const;
  inline void clear_spritesheetitems();
  static const int kSpritesheetItemsFieldNumber = 9;
  inline const ::com::laex::cg2d::model::CGEntitySpritesheetItem& spritesheetitems(int index) const;
  inline ::com::laex::cg2d::model::CGEntitySpritesheetItem* mutable_spritesheetitems(int index);
  inline ::com::laex::cg2d::model::CGEntitySpritesheetItem* add_spritesheetitems();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntitySpritesheetItem >&
      spritesheetitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntitySpritesheetItem >*
      mutable_spritesheetitems();

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGEntityAnimation)
 private:
  inline void set_has_animationname();
  inline void clear_has_animationname();
  inline void set_has_animationduration();
  inline void clear_has_animationduration();
  inline void set_has_defaultanimation();
  inline void clear_has_defaultanimation();
  inline void set_has_collisiontype();
  inline void clear_has_collisiontype();
  inline void set_has_spritesheetfile();
  inline void clear_has_spritesheetfile();
  inline void set_has_spritesheetjsonfile();
  inline void clear_has_spritesheetjsonfile();
  inline void set_has_fixturefile();
  inline void clear_has_fixturefile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* animationname_;
  float animationduration_;
  bool defaultanimation_;
  ::com::laex::cg2d::model::CGResourceFile* spritesheetfile_;
  ::com::laex::cg2d::model::CGResourceFile* spritesheetjsonfile_;
  ::com::laex::cg2d::model::CGResourceFile* fixturefile_;
  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGVector2 > vertices_;
  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntitySpritesheetItem > spritesheetitems_;
  int collisiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGEntityAnimation* default_instance_;
};
// -------------------------------------------------------------------

class CGEntity : public ::google::protobuf::Message {
 public:
  CGEntity();
  virtual ~CGEntity();

  CGEntity(const CGEntity& from);

  inline CGEntity& operator=(const CGEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGEntity& default_instance();

  void Swap(CGEntity* other);

  // implements Message ----------------------------------------------

  CGEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGEntity& from);
  void MergeFrom(const CGEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.laex.cg2d.model.CGEntityAnimation animations = 1;
  inline int animations_size() const;
  inline void clear_animations();
  static const int kAnimationsFieldNumber = 1;
  inline const ::com::laex::cg2d::model::CGEntityAnimation& animations(int index) const;
  inline ::com::laex::cg2d::model::CGEntityAnimation* mutable_animations(int index);
  inline ::com::laex::cg2d::model::CGEntityAnimation* add_animations();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntityAnimation >&
      animations() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntityAnimation >*
      mutable_animations();

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGEntity)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntityAnimation > animations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGEntity* default_instance_;
};
// -------------------------------------------------------------------

class CGBounds : public ::google::protobuf::Message {
 public:
  CGBounds();
  virtual ~CGBounds();

  CGBounds(const CGBounds& from);

  inline CGBounds& operator=(const CGBounds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGBounds& default_instance();

  void Swap(CGBounds* other);

  // implements Message ----------------------------------------------

  CGBounds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGBounds& from);
  void MergeFrom(const CGBounds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline float width() const;
  inline void set_width(float value);

  // optional float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline float height() const;
  inline void set_height(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGBounds)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float width_;
  float height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGBounds* default_instance_;
};
// -------------------------------------------------------------------

class CGVector2 : public ::google::protobuf::Message {
 public:
  CGVector2();
  virtual ~CGVector2();

  CGVector2(const CGVector2& from);

  inline CGVector2& operator=(const CGVector2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGVector2& default_instance();

  void Swap(CGVector2* other);

  // implements Message ----------------------------------------------

  CGVector2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGVector2& from);
  void MergeFrom(const CGVector2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGVector2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGVector2* default_instance_;
};
// -------------------------------------------------------------------

class CGColor : public ::google::protobuf::Message {
 public:
  CGColor();
  virtual ~CGColor();

  CGColor(const CGColor& from);

  inline CGColor& operator=(const CGColor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGColor& default_instance();

  void Swap(CGColor* other);

  // implements Message ----------------------------------------------

  CGColor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGColor& from);
  void MergeFrom(const CGColor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);

  // required int32 g = 2;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline ::google::protobuf::int32 g() const;
  inline void set_g(::google::protobuf::int32 value);

  // required int32 b = 3;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGColor)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGColor* default_instance_;
};
// -------------------------------------------------------------------

class CGBodyDef : public ::google::protobuf::Message {
 public:
  CGBodyDef();
  virtual ~CGBodyDef();

  CGBodyDef(const CGBodyDef& from);

  inline CGBodyDef& operator=(const CGBodyDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGBodyDef& default_instance();

  void Swap(CGBodyDef* other);

  // implements Message ----------------------------------------------

  CGBodyDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGBodyDef& from);
  void MergeFrom(const CGBodyDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // optional bool allowSleep = 2;
  inline bool has_allowsleep() const;
  inline void clear_allowsleep();
  static const int kAllowSleepFieldNumber = 2;
  inline bool allowsleep() const;
  inline void set_allowsleep(bool value);

  // optional float angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline float angle() const;
  inline void set_angle(float value);

  // optional float angularDamping = 4;
  inline bool has_angulardamping() const;
  inline void clear_angulardamping();
  static const int kAngularDampingFieldNumber = 4;
  inline float angulardamping() const;
  inline void set_angulardamping(float value);

  // optional float angularVelocity = 5;
  inline bool has_angularvelocity() const;
  inline void clear_angularvelocity();
  static const int kAngularVelocityFieldNumber = 5;
  inline float angularvelocity() const;
  inline void set_angularvelocity(float value);

  // optional bool awake = 6;
  inline bool has_awake() const;
  inline void clear_awake();
  static const int kAwakeFieldNumber = 6;
  inline bool awake() const;
  inline void set_awake(bool value);

  // optional bool bullet = 7;
  inline bool has_bullet() const;
  inline void clear_bullet();
  static const int kBulletFieldNumber = 7;
  inline bool bullet() const;
  inline void set_bullet(bool value);

  // optional bool fixedRotation = 8;
  inline bool has_fixedrotation() const;
  inline void clear_fixedrotation();
  static const int kFixedRotationFieldNumber = 8;
  inline bool fixedrotation() const;
  inline void set_fixedrotation(bool value);

  // optional float intertialScale = 9;
  inline bool has_intertialscale() const;
  inline void clear_intertialscale();
  static const int kIntertialScaleFieldNumber = 9;
  inline float intertialscale() const;
  inline void set_intertialscale(float value);

  // optional float linearDamping = 10;
  inline bool has_lineardamping() const;
  inline void clear_lineardamping();
  static const int kLinearDampingFieldNumber = 10;
  inline float lineardamping() const;
  inline void set_lineardamping(float value);

  // optional float gravityScale = 11;
  inline bool has_gravityscale() const;
  inline void clear_gravityscale();
  static const int kGravityScaleFieldNumber = 11;
  inline float gravityscale() const;
  inline void set_gravityscale(float value);

  // optional .com.laex.cg2d.model.CGVector2 linearVelocity = 12;
  inline bool has_linearvelocity() const;
  inline void clear_linearvelocity();
  static const int kLinearVelocityFieldNumber = 12;
  inline const ::com::laex::cg2d::model::CGVector2& linearvelocity() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_linearvelocity();
  inline ::com::laex::cg2d::model::CGVector2* release_linearvelocity();
  inline void set_allocated_linearvelocity(::com::laex::cg2d::model::CGVector2* linearvelocity);

  // optional .com.laex.cg2d.model.CGBodyType type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline ::com::laex::cg2d::model::CGBodyType type() const;
  inline void set_type(::com::laex::cg2d::model::CGBodyType value);

  // optional .com.laex.cg2d.model.CGVector2 position = 14;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 14;
  inline const ::com::laex::cg2d::model::CGVector2& position() const;
  inline ::com::laex::cg2d::model::CGVector2* mutable_position();
  inline ::com::laex::cg2d::model::CGVector2* release_position();
  inline void set_allocated_position(::com::laex::cg2d::model::CGVector2* position);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGBodyDef)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_allowsleep();
  inline void clear_has_allowsleep();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_angulardamping();
  inline void clear_has_angulardamping();
  inline void set_has_angularvelocity();
  inline void clear_has_angularvelocity();
  inline void set_has_awake();
  inline void clear_has_awake();
  inline void set_has_bullet();
  inline void clear_has_bullet();
  inline void set_has_fixedrotation();
  inline void clear_has_fixedrotation();
  inline void set_has_intertialscale();
  inline void clear_has_intertialscale();
  inline void set_has_lineardamping();
  inline void clear_has_lineardamping();
  inline void set_has_gravityscale();
  inline void clear_has_gravityscale();
  inline void set_has_linearvelocity();
  inline void clear_has_linearvelocity();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float angle_;
  float angulardamping_;
  bool active_;
  bool allowsleep_;
  bool awake_;
  bool bullet_;
  float angularvelocity_;
  bool fixedrotation_;
  float intertialscale_;
  float lineardamping_;
  float gravityscale_;
  ::com::laex::cg2d::model::CGVector2* linearvelocity_;
  ::com::laex::cg2d::model::CGVector2* position_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGBodyDef* default_instance_;
};
// -------------------------------------------------------------------

class CGFilter : public ::google::protobuf::Message {
 public:
  CGFilter();
  virtual ~CGFilter();

  CGFilter(const CGFilter& from);

  inline CGFilter& operator=(const CGFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGFilter& default_instance();

  void Swap(CGFilter* other);

  // implements Message ----------------------------------------------

  CGFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGFilter& from);
  void MergeFrom(const CGFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 categoryBits = 1;
  inline bool has_categorybits() const;
  inline void clear_categorybits();
  static const int kCategoryBitsFieldNumber = 1;
  inline ::google::protobuf::int32 categorybits() const;
  inline void set_categorybits(::google::protobuf::int32 value);

  // optional int32 maskBits = 2;
  inline bool has_maskbits() const;
  inline void clear_maskbits();
  static const int kMaskBitsFieldNumber = 2;
  inline ::google::protobuf::int32 maskbits() const;
  inline void set_maskbits(::google::protobuf::int32 value);

  // optional int32 groupIndex = 3;
  inline bool has_groupindex() const;
  inline void clear_groupindex();
  static const int kGroupIndexFieldNumber = 3;
  inline ::google::protobuf::int32 groupindex() const;
  inline void set_groupindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGFilter)
 private:
  inline void set_has_categorybits();
  inline void clear_has_categorybits();
  inline void set_has_maskbits();
  inline void clear_has_maskbits();
  inline void set_has_groupindex();
  inline void clear_has_groupindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 categorybits_;
  ::google::protobuf::int32 maskbits_;
  ::google::protobuf::int32 groupindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGFilter* default_instance_;
};
// -------------------------------------------------------------------

class CGFixtureDef : public ::google::protobuf::Message {
 public:
  CGFixtureDef();
  virtual ~CGFixtureDef();

  CGFixtureDef(const CGFixtureDef& from);

  inline CGFixtureDef& operator=(const CGFixtureDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGFixtureDef& default_instance();

  void Swap(CGFixtureDef* other);

  // implements Message ----------------------------------------------

  CGFixtureDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGFixtureDef& from);
  void MergeFrom(const CGFixtureDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float density = 1;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 1;
  inline float density() const;
  inline void set_density(float value);

  // optional float friction = 2;
  inline bool has_friction() const;
  inline void clear_friction();
  static const int kFrictionFieldNumber = 2;
  inline float friction() const;
  inline void set_friction(float value);

  // optional float restitution = 3;
  inline bool has_restitution() const;
  inline void clear_restitution();
  static const int kRestitutionFieldNumber = 3;
  inline float restitution() const;
  inline void set_restitution(float value);

  // optional bool sensor = 4;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 4;
  inline bool sensor() const;
  inline void set_sensor(bool value);

  // optional .com.laex.cg2d.model.CGFilter filter = 5;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 5;
  inline const ::com::laex::cg2d::model::CGFilter& filter() const;
  inline ::com::laex::cg2d::model::CGFilter* mutable_filter();
  inline ::com::laex::cg2d::model::CGFilter* release_filter();
  inline void set_allocated_filter(::com::laex::cg2d::model::CGFilter* filter);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGFixtureDef)
 private:
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_friction();
  inline void clear_has_friction();
  inline void set_has_restitution();
  inline void clear_has_restitution();
  inline void set_has_sensor();
  inline void clear_has_sensor();
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float density_;
  float friction_;
  float restitution_;
  bool sensor_;
  ::com::laex::cg2d::model::CGFilter* filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGFixtureDef* default_instance_;
};
// -------------------------------------------------------------------

class CGShape : public ::google::protobuf::Message {
 public:
  CGShape();
  virtual ~CGShape();

  CGShape(const CGShape& from);

  inline CGShape& operator=(const CGShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGShape& default_instance();

  void Swap(CGShape* other);

  // implements Message ----------------------------------------------

  CGShape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGShape& from);
  void MergeFrom(const CGShape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bool visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional bool locked = 3;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 3;
  inline bool locked() const;
  inline void set_locked(bool value);

  // optional bool background = 4;
  inline bool has_background() const;
  inline void clear_background();
  static const int kBackgroundFieldNumber = 4;
  inline bool background() const;
  inline void set_background(bool value);

  // optional .com.laex.cg2d.model.CGResourceFile backgroundResourceFile = 5;
  inline bool has_backgroundresourcefile() const;
  inline void clear_backgroundresourcefile();
  static const int kBackgroundResourceFileFieldNumber = 5;
  inline const ::com::laex::cg2d::model::CGResourceFile& backgroundresourcefile() const;
  inline ::com::laex::cg2d::model::CGResourceFile* mutable_backgroundresourcefile();
  inline ::com::laex::cg2d::model::CGResourceFile* release_backgroundresourcefile();
  inline void set_allocated_backgroundresourcefile(::com::laex::cg2d::model::CGResourceFile* backgroundresourcefile);

  // optional .com.laex.cg2d.model.CGEditorShapeType editorShapeType = 6;
  inline bool has_editorshapetype() const;
  inline void clear_editorshapetype();
  static const int kEditorShapeTypeFieldNumber = 6;
  inline ::com::laex::cg2d::model::CGEditorShapeType editorshapetype() const;
  inline void set_editorshapetype(::com::laex::cg2d::model::CGEditorShapeType value);

  // optional .com.laex.cg2d.model.CGBounds bounds = 7;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 7;
  inline const ::com::laex::cg2d::model::CGBounds& bounds() const;
  inline ::com::laex::cg2d::model::CGBounds* mutable_bounds();
  inline ::com::laex::cg2d::model::CGBounds* release_bounds();
  inline void set_allocated_bounds(::com::laex::cg2d::model::CGBounds* bounds);

  // optional .com.laex.cg2d.model.CGBodyDef bodyDef = 8;
  inline bool has_bodydef() const;
  inline void clear_bodydef();
  static const int kBodyDefFieldNumber = 8;
  inline const ::com::laex::cg2d::model::CGBodyDef& bodydef() const;
  inline ::com::laex::cg2d::model::CGBodyDef* mutable_bodydef();
  inline ::com::laex::cg2d::model::CGBodyDef* release_bodydef();
  inline void set_allocated_bodydef(::com::laex::cg2d::model::CGBodyDef* bodydef);

  // optional .com.laex.cg2d.model.CGFixtureDef fixtureDef = 9;
  inline bool has_fixturedef() const;
  inline void clear_fixturedef();
  static const int kFixtureDefFieldNumber = 9;
  inline const ::com::laex::cg2d::model::CGFixtureDef& fixturedef() const;
  inline ::com::laex::cg2d::model::CGFixtureDef* mutable_fixturedef();
  inline ::com::laex::cg2d::model::CGFixtureDef* release_fixturedef();
  inline void set_allocated_fixturedef(::com::laex::cg2d::model::CGFixtureDef* fixturedef);

  // repeated .com.laex.cg2d.model.CGJoint joints = 10;
  inline int joints_size() const;
  inline void clear_joints();
  static const int kJointsFieldNumber = 10;
  inline const ::com::laex::cg2d::model::CGJoint& joints(int index) const;
  inline ::com::laex::cg2d::model::CGJoint* mutable_joints(int index);
  inline ::com::laex::cg2d::model::CGJoint* add_joints();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGJoint >&
      joints() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGJoint >*
      mutable_joints();

  // optional .com.laex.cg2d.model.CGResourceFile entityRefFile = 11;
  inline bool has_entityreffile() const;
  inline void clear_entityreffile();
  static const int kEntityRefFileFieldNumber = 11;
  inline const ::com::laex::cg2d::model::CGResourceFile& entityreffile() const;
  inline ::com::laex::cg2d::model::CGResourceFile* mutable_entityreffile();
  inline ::com::laex::cg2d::model::CGResourceFile* release_entityreffile();
  inline void set_allocated_entityreffile(::com::laex::cg2d::model::CGResourceFile* entityreffile);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGShape)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_background();
  inline void clear_has_background();
  inline void set_has_backgroundresourcefile();
  inline void clear_has_backgroundresourcefile();
  inline void set_has_editorshapetype();
  inline void clear_has_editorshapetype();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  inline void set_has_bodydef();
  inline void clear_has_bodydef();
  inline void set_has_fixturedef();
  inline void clear_has_fixturedef();
  inline void set_has_entityreffile();
  inline void clear_has_entityreffile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  bool visible_;
  bool locked_;
  bool background_;
  int editorshapetype_;
  ::com::laex::cg2d::model::CGResourceFile* backgroundresourcefile_;
  ::com::laex::cg2d::model::CGBounds* bounds_;
  ::com::laex::cg2d::model::CGBodyDef* bodydef_;
  ::com::laex::cg2d::model::CGFixtureDef* fixturedef_;
  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGJoint > joints_;
  ::com::laex::cg2d::model::CGResourceFile* entityreffile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGShape* default_instance_;
};
// -------------------------------------------------------------------

class CGLayer : public ::google::protobuf::Message {
 public:
  CGLayer();
  virtual ~CGLayer();

  CGLayer(const CGLayer& from);

  inline CGLayer& operator=(const CGLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGLayer& default_instance();

  void Swap(CGLayer* other);

  // implements Message ----------------------------------------------

  CGLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGLayer& from);
  void MergeFrom(const CGLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool visible = 3;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 3;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional bool locked = 4;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 4;
  inline bool locked() const;
  inline void set_locked(bool value);

  // repeated .com.laex.cg2d.model.CGShape shape = 5;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 5;
  inline const ::com::laex::cg2d::model::CGShape& shape(int index) const;
  inline ::com::laex::cg2d::model::CGShape* mutable_shape(int index);
  inline ::com::laex::cg2d::model::CGShape* add_shape();
  inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGShape >&
      shape() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGShape >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGLayer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_locked();
  inline void clear_has_locked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  bool visible_;
  bool locked_;
  ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGShape > shape_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGLayer* default_instance_;
};
// -------------------------------------------------------------------

class CGScreenPreferences_CGDebugDrawPreferences : public ::google::protobuf::Message {
 public:
  CGScreenPreferences_CGDebugDrawPreferences();
  virtual ~CGScreenPreferences_CGDebugDrawPreferences();

  CGScreenPreferences_CGDebugDrawPreferences(const CGScreenPreferences_CGDebugDrawPreferences& from);

  inline CGScreenPreferences_CGDebugDrawPreferences& operator=(const CGScreenPreferences_CGDebugDrawPreferences& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGScreenPreferences_CGDebugDrawPreferences& default_instance();

  void Swap(CGScreenPreferences_CGDebugDrawPreferences* other);

  // implements Message ----------------------------------------------

  CGScreenPreferences_CGDebugDrawPreferences* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGScreenPreferences_CGDebugDrawPreferences& from);
  void MergeFrom(const CGScreenPreferences_CGDebugDrawPreferences& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool drawBodies = 1;
  inline bool has_drawbodies() const;
  inline void clear_drawbodies();
  static const int kDrawBodiesFieldNumber = 1;
  inline bool drawbodies() const;
  inline void set_drawbodies(bool value);

  // optional bool drawJoints = 2;
  inline bool has_drawjoints() const;
  inline void clear_drawjoints();
  static const int kDrawJointsFieldNumber = 2;
  inline bool drawjoints() const;
  inline void set_drawjoints(bool value);

  // optional bool drawAABB = 3;
  inline bool has_drawaabb() const;
  inline void clear_drawaabb();
  static const int kDrawAABBFieldNumber = 3;
  inline bool drawaabb() const;
  inline void set_drawaabb(bool value);

  // optional bool drawInactiveBodies = 4;
  inline bool has_drawinactivebodies() const;
  inline void clear_drawinactivebodies();
  static const int kDrawInactiveBodiesFieldNumber = 4;
  inline bool drawinactivebodies() const;
  inline void set_drawinactivebodies(bool value);

  // optional bool installMouseJoint = 5;
  inline bool has_installmousejoint() const;
  inline void clear_installmousejoint();
  static const int kInstallMouseJointFieldNumber = 5;
  inline bool installmousejoint() const;
  inline void set_installmousejoint(bool value);

  // optional bool drawDebugData = 6;
  inline bool has_drawdebugdata() const;
  inline void clear_drawdebugdata();
  static const int kDrawDebugDataFieldNumber = 6;
  inline bool drawdebugdata() const;
  inline void set_drawdebugdata(bool value);

  // optional bool drawEntities = 7;
  inline bool has_drawentities() const;
  inline void clear_drawentities();
  static const int kDrawEntitiesFieldNumber = 7;
  inline bool drawentities() const;
  inline void set_drawentities(bool value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGScreenPreferences.CGDebugDrawPreferences)
 private:
  inline void set_has_drawbodies();
  inline void clear_has_drawbodies();
  inline void set_has_drawjoints();
  inline void clear_has_drawjoints();
  inline void set_has_drawaabb();
  inline void clear_has_drawaabb();
  inline void set_has_drawinactivebodies();
  inline void clear_has_drawinactivebodies();
  inline void set_has_installmousejoint();
  inline void clear_has_installmousejoint();
  inline void set_has_drawdebugdata();
  inline void clear_has_drawdebugdata();
  inline void set_has_drawentities();
  inline void clear_has_drawentities();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool drawbodies_;
  bool drawjoints_;
  bool drawaabb_;
  bool drawinactivebodies_;
  bool installmousejoint_;
  bool drawdebugdata_;
  bool drawentities_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGScreenPreferences_CGDebugDrawPreferences* default_instance_;
};
// -------------------------------------------------------------------

class CGScreenPreferences_CGWorldPreferences : public ::google::protobuf::Message {
 public:
  CGScreenPreferences_CGWorldPreferences();
  virtual ~CGScreenPreferences_CGWorldPreferences();

  CGScreenPreferences_CGWorldPreferences(const CGScreenPreferences_CGWorldPreferences& from);

  inline CGScreenPreferences_CGWorldPreferences& operator=(const CGScreenPreferences_CGWorldPreferences& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGScreenPreferences_CGWorldPreferences& default_instance();

  void Swap(CGScreenPreferences_CGWorldPreferences* other);

  // implements Message ----------------------------------------------

  CGScreenPreferences_CGWorldPreferences* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGScreenPreferences_CGWorldPreferences& from);
  void MergeFrom(const CGScreenPreferences_CGWorldPreferences& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ptmRatio = 1;
  inline bool has_ptmratio() const;
  inline void clear_ptmratio();
  static const int kPtmRatioFieldNumber = 1;
  inline ::google::protobuf::int32 ptmratio() const;
  inline void set_ptmratio(::google::protobuf::int32 value);

  // optional int32 velocityIterations = 2;
  inline bool has_velocityiterations() const;
  inline void clear_velocityiterations();
  static const int kVelocityIterationsFieldNumber = 2;
  inline ::google::protobuf::int32 velocityiterations() const;
  inline void set_velocityiterations(::google::protobuf::int32 value);

  // optional int32 positionIterations = 3;
  inline bool has_positioniterations() const;
  inline void clear_positioniterations();
  static const int kPositionIterationsFieldNumber = 3;
  inline ::google::protobuf::int32 positioniterations() const;
  inline void set_positioniterations(::google::protobuf::int32 value);

  // optional float timeStep = 4;
  inline bool has_timestep() const;
  inline void clear_timestep();
  static const int kTimeStepFieldNumber = 4;
  inline float timestep() const;
  inline void set_timestep(float value);

  // optional float gravityX = 5;
  inline bool has_gravityx() const;
  inline void clear_gravityx();
  static const int kGravityXFieldNumber = 5;
  inline float gravityx() const;
  inline void set_gravityx(float value);

  // optional float gravityY = 6;
  inline bool has_gravityy() const;
  inline void clear_gravityy();
  static const int kGravityYFieldNumber = 6;
  inline float gravityy() const;
  inline void set_gravityy(float value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGScreenPreferences.CGWorldPreferences)
 private:
  inline void set_has_ptmratio();
  inline void clear_has_ptmratio();
  inline void set_has_velocityiterations();
  inline void clear_has_velocityiterations();
  inline void set_has_positioniterations();
  inline void clear_has_positioniterations();
  inline void set_has_timestep();
  inline void clear_has_timestep();
  inline void set_has_gravityx();
  inline void clear_has_gravityx();
  inline void set_has_gravityy();
  inline void clear_has_gravityy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ptmratio_;
  ::google::protobuf::int32 velocityiterations_;
  ::google::protobuf::int32 positioniterations_;
  float timestep_;
  float gravityx_;
  float gravityy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGScreenPreferences_CGWorldPreferences* default_instance_;
};
// -------------------------------------------------------------------

class CGScreenPreferences_CGCardPreferences : public ::google::protobuf::Message {
 public:
  CGScreenPreferences_CGCardPreferences();
  virtual ~CGScreenPreferences_CGCardPreferences();

  CGScreenPreferences_CGCardPreferences(const CGScreenPreferences_CGCardPreferences& from);

  inline CGScreenPreferences_CGCardPreferences& operator=(const CGScreenPreferences_CGCardPreferences& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGScreenPreferences_CGCardPreferences& default_instance();

  void Swap(CGScreenPreferences_CGCardPreferences* other);

  // implements Message ----------------------------------------------

  CGScreenPreferences_CGCardPreferences* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGScreenPreferences_CGCardPreferences& from);
  void MergeFrom(const CGScreenPreferences_CGCardPreferences& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cardNoX = 1;
  inline bool has_cardnox() const;
  inline void clear_cardnox();
  static const int kCardNoXFieldNumber = 1;
  inline ::google::protobuf::int32 cardnox() const;
  inline void set_cardnox(::google::protobuf::int32 value);

  // optional int32 cardNoY = 2;
  inline bool has_cardnoy() const;
  inline void clear_cardnoy();
  static const int kCardNoYFieldNumber = 2;
  inline ::google::protobuf::int32 cardnoy() const;
  inline void set_cardnoy(::google::protobuf::int32 value);

  // optional int32 cardWidth = 3;
  inline bool has_cardwidth() const;
  inline void clear_cardwidth();
  static const int kCardWidthFieldNumber = 3;
  inline ::google::protobuf::int32 cardwidth() const;
  inline void set_cardwidth(::google::protobuf::int32 value);

  // optional int32 cardHeight = 4;
  inline bool has_cardheight() const;
  inline void clear_cardheight();
  static const int kCardHeightFieldNumber = 4;
  inline ::google::protobuf::int32 cardheight() const;
  inline void set_cardheight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGScreenPreferences.CGCardPreferences)
 private:
  inline void set_has_cardnox();
  inline void clear_has_cardnox();
  inline void set_has_cardnoy();
  inline void clear_has_cardnoy();
  inline void set_has_cardwidth();
  inline void clear_has_cardwidth();
  inline void set_has_cardheight();
  inline void clear_has_cardheight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 cardnox_;
  ::google::protobuf::int32 cardnoy_;
  ::google::protobuf::int32 cardwidth_;
  ::google::protobuf::int32 cardheight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGScreenPreferences_CGCardPreferences* default_instance_;
};
// -------------------------------------------------------------------

class CGScreenPreferences : public ::google::protobuf::Message {
 public:
  CGScreenPreferences();
  virtual ~CGScreenPreferences();

  CGScreenPreferences(const CGScreenPreferences& from);

  inline CGScreenPreferences& operator=(const CGScreenPreferences& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGScreenPreferences& default_instance();

  void Swap(CGScreenPreferences* other);

  // implements Message ----------------------------------------------

  CGScreenPreferences* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGScreenPreferences& from);
  void MergeFrom(const CGScreenPreferences& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CGScreenPreferences_CGDebugDrawPreferences CGDebugDrawPreferences;
  typedef CGScreenPreferences_CGWorldPreferences CGWorldPreferences;
  typedef CGScreenPreferences_CGCardPreferences CGCardPreferences;

  // accessors -------------------------------------------------------

  // optional .com.laex.cg2d.model.CGScreenPreferences.CGDebugDrawPreferences debugDrawPrefs = 1;
  inline bool has_debugdrawprefs() const;
  inline void clear_debugdrawprefs();
  static const int kDebugDrawPrefsFieldNumber = 1;
  inline const ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences& debugdrawprefs() const;
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* mutable_debugdrawprefs();
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* release_debugdrawprefs();
  inline void set_allocated_debugdrawprefs(::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* debugdrawprefs);

  // optional .com.laex.cg2d.model.CGScreenPreferences.CGWorldPreferences worldPrefs = 2;
  inline bool has_worldprefs() const;
  inline void clear_worldprefs();
  static const int kWorldPrefsFieldNumber = 2;
  inline const ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences& worldprefs() const;
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* mutable_worldprefs();
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* release_worldprefs();
  inline void set_allocated_worldprefs(::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* worldprefs);

  // optional .com.laex.cg2d.model.CGScreenPreferences.CGCardPreferences cardPrefs = 3;
  inline bool has_cardprefs() const;
  inline void clear_cardprefs();
  static const int kCardPrefsFieldNumber = 3;
  inline const ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences& cardprefs() const;
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* mutable_cardprefs();
  inline ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* release_cardprefs();
  inline void set_allocated_cardprefs(::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* cardprefs);

  // optional .com.laex.cg2d.model.CGColor backgroundColor = 4;
  inline bool has_backgroundcolor() const;
  inline void clear_backgroundcolor();
  static const int kBackgroundColorFieldNumber = 4;
  inline const ::com::laex::cg2d::model::CGColor& backgroundcolor() const;
  inline ::com::laex::cg2d::model::CGColor* mutable_backgroundcolor();
  inline ::com::laex::cg2d::model::CGColor* release_backgroundcolor();
  inline void set_allocated_backgroundcolor(::com::laex::cg2d::model::CGColor* backgroundcolor);

  // @@protoc_insertion_point(class_scope:com.laex.cg2d.model.CGScreenPreferences)
 private:
  inline void set_has_debugdrawprefs();
  inline void clear_has_debugdrawprefs();
  inline void set_has_worldprefs();
  inline void clear_has_worldprefs();
  inline void set_has_cardprefs();
  inline void clear_has_cardprefs();
  inline void set_has_backgroundcolor();
  inline void clear_has_backgroundcolor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* debugdrawprefs_;
  ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* worldprefs_;
  ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* cardprefs_;
  ::com::laex::cg2d::model::CGColor* backgroundcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_AssignDesc_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();
  friend void protobuf_ShutdownFile_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto();

  void InitAsDefaultInstance();
  static CGScreenPreferences* default_instance_;
};
// ===================================================================


// ===================================================================

// CGScreenModel

// optional .com.laex.cg2d.model.CGScreenPreferences screenPrefs = 1;
inline bool CGScreenModel::has_screenprefs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGScreenModel::set_has_screenprefs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGScreenModel::clear_has_screenprefs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGScreenModel::clear_screenprefs() {
  if (screenprefs_ != NULL) screenprefs_->::com::laex::cg2d::model::CGScreenPreferences::Clear();
  clear_has_screenprefs();
}
inline const ::com::laex::cg2d::model::CGScreenPreferences& CGScreenModel::screenprefs() const {
  return screenprefs_ != NULL ? *screenprefs_ : *default_instance_->screenprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences* CGScreenModel::mutable_screenprefs() {
  set_has_screenprefs();
  if (screenprefs_ == NULL) screenprefs_ = new ::com::laex::cg2d::model::CGScreenPreferences;
  return screenprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences* CGScreenModel::release_screenprefs() {
  clear_has_screenprefs();
  ::com::laex::cg2d::model::CGScreenPreferences* temp = screenprefs_;
  screenprefs_ = NULL;
  return temp;
}
inline void CGScreenModel::set_allocated_screenprefs(::com::laex::cg2d::model::CGScreenPreferences* screenprefs) {
  delete screenprefs_;
  screenprefs_ = screenprefs;
  if (screenprefs) {
    set_has_screenprefs();
  } else {
    clear_has_screenprefs();
  }
}

// repeated .com.laex.cg2d.model.CGLayer layers = 2;
inline int CGScreenModel::layers_size() const {
  return layers_.size();
}
inline void CGScreenModel::clear_layers() {
  layers_.Clear();
}
inline const ::com::laex::cg2d::model::CGLayer& CGScreenModel::layers(int index) const {
  return layers_.Get(index);
}
inline ::com::laex::cg2d::model::CGLayer* CGScreenModel::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGLayer* CGScreenModel::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGLayer >&
CGScreenModel::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGLayer >*
CGScreenModel::mutable_layers() {
  return &layers_;
}

// -------------------------------------------------------------------

// CGJoint

// optional string sourceShapeId = 1;
inline bool CGJoint::has_sourceshapeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGJoint::set_has_sourceshapeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGJoint::clear_has_sourceshapeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGJoint::clear_sourceshapeid() {
  if (sourceshapeid_ != &::google::protobuf::internal::kEmptyString) {
    sourceshapeid_->clear();
  }
  clear_has_sourceshapeid();
}
inline const ::std::string& CGJoint::sourceshapeid() const {
  return *sourceshapeid_;
}
inline void CGJoint::set_sourceshapeid(const ::std::string& value) {
  set_has_sourceshapeid();
  if (sourceshapeid_ == &::google::protobuf::internal::kEmptyString) {
    sourceshapeid_ = new ::std::string;
  }
  sourceshapeid_->assign(value);
}
inline void CGJoint::set_sourceshapeid(const char* value) {
  set_has_sourceshapeid();
  if (sourceshapeid_ == &::google::protobuf::internal::kEmptyString) {
    sourceshapeid_ = new ::std::string;
  }
  sourceshapeid_->assign(value);
}
inline void CGJoint::set_sourceshapeid(const char* value, size_t size) {
  set_has_sourceshapeid();
  if (sourceshapeid_ == &::google::protobuf::internal::kEmptyString) {
    sourceshapeid_ = new ::std::string;
  }
  sourceshapeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGJoint::mutable_sourceshapeid() {
  set_has_sourceshapeid();
  if (sourceshapeid_ == &::google::protobuf::internal::kEmptyString) {
    sourceshapeid_ = new ::std::string;
  }
  return sourceshapeid_;
}
inline ::std::string* CGJoint::release_sourceshapeid() {
  clear_has_sourceshapeid();
  if (sourceshapeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sourceshapeid_;
    sourceshapeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGJoint::set_allocated_sourceshapeid(::std::string* sourceshapeid) {
  if (sourceshapeid_ != &::google::protobuf::internal::kEmptyString) {
    delete sourceshapeid_;
  }
  if (sourceshapeid) {
    set_has_sourceshapeid();
    sourceshapeid_ = sourceshapeid;
  } else {
    clear_has_sourceshapeid();
    sourceshapeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string targetShapeId = 2;
inline bool CGJoint::has_targetshapeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGJoint::set_has_targetshapeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGJoint::clear_has_targetshapeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGJoint::clear_targetshapeid() {
  if (targetshapeid_ != &::google::protobuf::internal::kEmptyString) {
    targetshapeid_->clear();
  }
  clear_has_targetshapeid();
}
inline const ::std::string& CGJoint::targetshapeid() const {
  return *targetshapeid_;
}
inline void CGJoint::set_targetshapeid(const ::std::string& value) {
  set_has_targetshapeid();
  if (targetshapeid_ == &::google::protobuf::internal::kEmptyString) {
    targetshapeid_ = new ::std::string;
  }
  targetshapeid_->assign(value);
}
inline void CGJoint::set_targetshapeid(const char* value) {
  set_has_targetshapeid();
  if (targetshapeid_ == &::google::protobuf::internal::kEmptyString) {
    targetshapeid_ = new ::std::string;
  }
  targetshapeid_->assign(value);
}
inline void CGJoint::set_targetshapeid(const char* value, size_t size) {
  set_has_targetshapeid();
  if (targetshapeid_ == &::google::protobuf::internal::kEmptyString) {
    targetshapeid_ = new ::std::string;
  }
  targetshapeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGJoint::mutable_targetshapeid() {
  set_has_targetshapeid();
  if (targetshapeid_ == &::google::protobuf::internal::kEmptyString) {
    targetshapeid_ = new ::std::string;
  }
  return targetshapeid_;
}
inline ::std::string* CGJoint::release_targetshapeid() {
  clear_has_targetshapeid();
  if (targetshapeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetshapeid_;
    targetshapeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGJoint::set_allocated_targetshapeid(::std::string* targetshapeid) {
  if (targetshapeid_ != &::google::protobuf::internal::kEmptyString) {
    delete targetshapeid_;
  }
  if (targetshapeid) {
    set_has_targetshapeid();
    targetshapeid_ = targetshapeid;
  } else {
    clear_has_targetshapeid();
    targetshapeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.laex.cg2d.model.CGJointType type = 3;
inline bool CGJoint::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGJoint::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGJoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGJoint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::laex::cg2d::model::CGJointType CGJoint::type() const {
  return static_cast< ::com::laex::cg2d::model::CGJointType >(type_);
}
inline void CGJoint::set_type(::com::laex::cg2d::model::CGJointType value) {
  assert(::com::laex::cg2d::model::CGJointType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .com.laex.cg2d.model.CGDistanceJointDef distanceJointDef = 5;
inline bool CGJoint::has_distancejointdef() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGJoint::set_has_distancejointdef() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGJoint::clear_has_distancejointdef() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGJoint::clear_distancejointdef() {
  if (distancejointdef_ != NULL) distancejointdef_->::com::laex::cg2d::model::CGDistanceJointDef::Clear();
  clear_has_distancejointdef();
}
inline const ::com::laex::cg2d::model::CGDistanceJointDef& CGJoint::distancejointdef() const {
  return distancejointdef_ != NULL ? *distancejointdef_ : *default_instance_->distancejointdef_;
}
inline ::com::laex::cg2d::model::CGDistanceJointDef* CGJoint::mutable_distancejointdef() {
  set_has_distancejointdef();
  if (distancejointdef_ == NULL) distancejointdef_ = new ::com::laex::cg2d::model::CGDistanceJointDef;
  return distancejointdef_;
}
inline ::com::laex::cg2d::model::CGDistanceJointDef* CGJoint::release_distancejointdef() {
  clear_has_distancejointdef();
  ::com::laex::cg2d::model::CGDistanceJointDef* temp = distancejointdef_;
  distancejointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_distancejointdef(::com::laex::cg2d::model::CGDistanceJointDef* distancejointdef) {
  delete distancejointdef_;
  distancejointdef_ = distancejointdef;
  if (distancejointdef) {
    set_has_distancejointdef();
  } else {
    clear_has_distancejointdef();
  }
}

// optional .com.laex.cg2d.model.CGRevoluteJointDef revoluteJointDef = 6;
inline bool CGJoint::has_revolutejointdef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGJoint::set_has_revolutejointdef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGJoint::clear_has_revolutejointdef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGJoint::clear_revolutejointdef() {
  if (revolutejointdef_ != NULL) revolutejointdef_->::com::laex::cg2d::model::CGRevoluteJointDef::Clear();
  clear_has_revolutejointdef();
}
inline const ::com::laex::cg2d::model::CGRevoluteJointDef& CGJoint::revolutejointdef() const {
  return revolutejointdef_ != NULL ? *revolutejointdef_ : *default_instance_->revolutejointdef_;
}
inline ::com::laex::cg2d::model::CGRevoluteJointDef* CGJoint::mutable_revolutejointdef() {
  set_has_revolutejointdef();
  if (revolutejointdef_ == NULL) revolutejointdef_ = new ::com::laex::cg2d::model::CGRevoluteJointDef;
  return revolutejointdef_;
}
inline ::com::laex::cg2d::model::CGRevoluteJointDef* CGJoint::release_revolutejointdef() {
  clear_has_revolutejointdef();
  ::com::laex::cg2d::model::CGRevoluteJointDef* temp = revolutejointdef_;
  revolutejointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_revolutejointdef(::com::laex::cg2d::model::CGRevoluteJointDef* revolutejointdef) {
  delete revolutejointdef_;
  revolutejointdef_ = revolutejointdef;
  if (revolutejointdef) {
    set_has_revolutejointdef();
  } else {
    clear_has_revolutejointdef();
  }
}

// optional .com.laex.cg2d.model.CGPrismaticJointDef prismaticJointDef = 7;
inline bool CGJoint::has_prismaticjointdef() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGJoint::set_has_prismaticjointdef() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGJoint::clear_has_prismaticjointdef() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGJoint::clear_prismaticjointdef() {
  if (prismaticjointdef_ != NULL) prismaticjointdef_->::com::laex::cg2d::model::CGPrismaticJointDef::Clear();
  clear_has_prismaticjointdef();
}
inline const ::com::laex::cg2d::model::CGPrismaticJointDef& CGJoint::prismaticjointdef() const {
  return prismaticjointdef_ != NULL ? *prismaticjointdef_ : *default_instance_->prismaticjointdef_;
}
inline ::com::laex::cg2d::model::CGPrismaticJointDef* CGJoint::mutable_prismaticjointdef() {
  set_has_prismaticjointdef();
  if (prismaticjointdef_ == NULL) prismaticjointdef_ = new ::com::laex::cg2d::model::CGPrismaticJointDef;
  return prismaticjointdef_;
}
inline ::com::laex::cg2d::model::CGPrismaticJointDef* CGJoint::release_prismaticjointdef() {
  clear_has_prismaticjointdef();
  ::com::laex::cg2d::model::CGPrismaticJointDef* temp = prismaticjointdef_;
  prismaticjointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_prismaticjointdef(::com::laex::cg2d::model::CGPrismaticJointDef* prismaticjointdef) {
  delete prismaticjointdef_;
  prismaticjointdef_ = prismaticjointdef;
  if (prismaticjointdef) {
    set_has_prismaticjointdef();
  } else {
    clear_has_prismaticjointdef();
  }
}

// optional .com.laex.cg2d.model.CGPulleyJointDef pulleyJointDef = 8;
inline bool CGJoint::has_pulleyjointdef() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGJoint::set_has_pulleyjointdef() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGJoint::clear_has_pulleyjointdef() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGJoint::clear_pulleyjointdef() {
  if (pulleyjointdef_ != NULL) pulleyjointdef_->::com::laex::cg2d::model::CGPulleyJointDef::Clear();
  clear_has_pulleyjointdef();
}
inline const ::com::laex::cg2d::model::CGPulleyJointDef& CGJoint::pulleyjointdef() const {
  return pulleyjointdef_ != NULL ? *pulleyjointdef_ : *default_instance_->pulleyjointdef_;
}
inline ::com::laex::cg2d::model::CGPulleyJointDef* CGJoint::mutable_pulleyjointdef() {
  set_has_pulleyjointdef();
  if (pulleyjointdef_ == NULL) pulleyjointdef_ = new ::com::laex::cg2d::model::CGPulleyJointDef;
  return pulleyjointdef_;
}
inline ::com::laex::cg2d::model::CGPulleyJointDef* CGJoint::release_pulleyjointdef() {
  clear_has_pulleyjointdef();
  ::com::laex::cg2d::model::CGPulleyJointDef* temp = pulleyjointdef_;
  pulleyjointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_pulleyjointdef(::com::laex::cg2d::model::CGPulleyJointDef* pulleyjointdef) {
  delete pulleyjointdef_;
  pulleyjointdef_ = pulleyjointdef;
  if (pulleyjointdef) {
    set_has_pulleyjointdef();
  } else {
    clear_has_pulleyjointdef();
  }
}

// optional .com.laex.cg2d.model.CGFrictionJointDef frictionJointDef = 9;
inline bool CGJoint::has_frictionjointdef() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGJoint::set_has_frictionjointdef() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGJoint::clear_has_frictionjointdef() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGJoint::clear_frictionjointdef() {
  if (frictionjointdef_ != NULL) frictionjointdef_->::com::laex::cg2d::model::CGFrictionJointDef::Clear();
  clear_has_frictionjointdef();
}
inline const ::com::laex::cg2d::model::CGFrictionJointDef& CGJoint::frictionjointdef() const {
  return frictionjointdef_ != NULL ? *frictionjointdef_ : *default_instance_->frictionjointdef_;
}
inline ::com::laex::cg2d::model::CGFrictionJointDef* CGJoint::mutable_frictionjointdef() {
  set_has_frictionjointdef();
  if (frictionjointdef_ == NULL) frictionjointdef_ = new ::com::laex::cg2d::model::CGFrictionJointDef;
  return frictionjointdef_;
}
inline ::com::laex::cg2d::model::CGFrictionJointDef* CGJoint::release_frictionjointdef() {
  clear_has_frictionjointdef();
  ::com::laex::cg2d::model::CGFrictionJointDef* temp = frictionjointdef_;
  frictionjointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_frictionjointdef(::com::laex::cg2d::model::CGFrictionJointDef* frictionjointdef) {
  delete frictionjointdef_;
  frictionjointdef_ = frictionjointdef;
  if (frictionjointdef) {
    set_has_frictionjointdef();
  } else {
    clear_has_frictionjointdef();
  }
}

// optional .com.laex.cg2d.model.CGWeldJointDef weldJointDef = 10;
inline bool CGJoint::has_weldjointdef() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CGJoint::set_has_weldjointdef() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CGJoint::clear_has_weldjointdef() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CGJoint::clear_weldjointdef() {
  if (weldjointdef_ != NULL) weldjointdef_->::com::laex::cg2d::model::CGWeldJointDef::Clear();
  clear_has_weldjointdef();
}
inline const ::com::laex::cg2d::model::CGWeldJointDef& CGJoint::weldjointdef() const {
  return weldjointdef_ != NULL ? *weldjointdef_ : *default_instance_->weldjointdef_;
}
inline ::com::laex::cg2d::model::CGWeldJointDef* CGJoint::mutable_weldjointdef() {
  set_has_weldjointdef();
  if (weldjointdef_ == NULL) weldjointdef_ = new ::com::laex::cg2d::model::CGWeldJointDef;
  return weldjointdef_;
}
inline ::com::laex::cg2d::model::CGWeldJointDef* CGJoint::release_weldjointdef() {
  clear_has_weldjointdef();
  ::com::laex::cg2d::model::CGWeldJointDef* temp = weldjointdef_;
  weldjointdef_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_weldjointdef(::com::laex::cg2d::model::CGWeldJointDef* weldjointdef) {
  delete weldjointdef_;
  weldjointdef_ = weldjointdef;
  if (weldjointdef) {
    set_has_weldjointdef();
  } else {
    clear_has_weldjointdef();
  }
}

// optional .com.laex.cg2d.model.CGVector2 localAnchorA = 11;
inline bool CGJoint::has_localanchora() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CGJoint::set_has_localanchora() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CGJoint::clear_has_localanchora() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CGJoint::clear_localanchora() {
  if (localanchora_ != NULL) localanchora_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_localanchora();
}
inline const ::com::laex::cg2d::model::CGVector2& CGJoint::localanchora() const {
  return localanchora_ != NULL ? *localanchora_ : *default_instance_->localanchora_;
}
inline ::com::laex::cg2d::model::CGVector2* CGJoint::mutable_localanchora() {
  set_has_localanchora();
  if (localanchora_ == NULL) localanchora_ = new ::com::laex::cg2d::model::CGVector2;
  return localanchora_;
}
inline ::com::laex::cg2d::model::CGVector2* CGJoint::release_localanchora() {
  clear_has_localanchora();
  ::com::laex::cg2d::model::CGVector2* temp = localanchora_;
  localanchora_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_localanchora(::com::laex::cg2d::model::CGVector2* localanchora) {
  delete localanchora_;
  localanchora_ = localanchora;
  if (localanchora) {
    set_has_localanchora();
  } else {
    clear_has_localanchora();
  }
}

// optional .com.laex.cg2d.model.CGVector2 localAnchorB = 12;
inline bool CGJoint::has_localanchorb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CGJoint::set_has_localanchorb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CGJoint::clear_has_localanchorb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CGJoint::clear_localanchorb() {
  if (localanchorb_ != NULL) localanchorb_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_localanchorb();
}
inline const ::com::laex::cg2d::model::CGVector2& CGJoint::localanchorb() const {
  return localanchorb_ != NULL ? *localanchorb_ : *default_instance_->localanchorb_;
}
inline ::com::laex::cg2d::model::CGVector2* CGJoint::mutable_localanchorb() {
  set_has_localanchorb();
  if (localanchorb_ == NULL) localanchorb_ = new ::com::laex::cg2d::model::CGVector2;
  return localanchorb_;
}
inline ::com::laex::cg2d::model::CGVector2* CGJoint::release_localanchorb() {
  clear_has_localanchorb();
  ::com::laex::cg2d::model::CGVector2* temp = localanchorb_;
  localanchorb_ = NULL;
  return temp;
}
inline void CGJoint::set_allocated_localanchorb(::com::laex::cg2d::model::CGVector2* localanchorb) {
  delete localanchorb_;
  localanchorb_ = localanchorb;
  if (localanchorb) {
    set_has_localanchorb();
  } else {
    clear_has_localanchorb();
  }
}

// optional bool useLocalAnchors = 13;
inline bool CGJoint::has_uselocalanchors() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CGJoint::set_has_uselocalanchors() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CGJoint::clear_has_uselocalanchors() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CGJoint::clear_uselocalanchors() {
  uselocalanchors_ = false;
  clear_has_uselocalanchors();
}
inline bool CGJoint::uselocalanchors() const {
  return uselocalanchors_;
}
inline void CGJoint::set_uselocalanchors(bool value) {
  set_has_uselocalanchors();
  uselocalanchors_ = value;
}

// -------------------------------------------------------------------

// CGDistanceJointDef

// optional bool collideConnected = 1;
inline bool CGDistanceJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGDistanceJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGDistanceJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGDistanceJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGDistanceJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGDistanceJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional float freqencyHz = 2;
inline bool CGDistanceJointDef::has_freqencyhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGDistanceJointDef::set_has_freqencyhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGDistanceJointDef::clear_has_freqencyhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGDistanceJointDef::clear_freqencyhz() {
  freqencyhz_ = 0;
  clear_has_freqencyhz();
}
inline float CGDistanceJointDef::freqencyhz() const {
  return freqencyhz_;
}
inline void CGDistanceJointDef::set_freqencyhz(float value) {
  set_has_freqencyhz();
  freqencyhz_ = value;
}

// optional float dampingRatio = 3;
inline bool CGDistanceJointDef::has_dampingratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGDistanceJointDef::set_has_dampingratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGDistanceJointDef::clear_has_dampingratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGDistanceJointDef::clear_dampingratio() {
  dampingratio_ = 0;
  clear_has_dampingratio();
}
inline float CGDistanceJointDef::dampingratio() const {
  return dampingratio_;
}
inline void CGDistanceJointDef::set_dampingratio(float value) {
  set_has_dampingratio();
  dampingratio_ = value;
}

// -------------------------------------------------------------------

// CGRevoluteJointDef

// optional bool collideConnected = 1;
inline bool CGRevoluteJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGRevoluteJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGRevoluteJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGRevoluteJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGRevoluteJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGRevoluteJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional float referenceAngle = 2;
inline bool CGRevoluteJointDef::has_referenceangle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGRevoluteJointDef::set_has_referenceangle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGRevoluteJointDef::clear_has_referenceangle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGRevoluteJointDef::clear_referenceangle() {
  referenceangle_ = 0;
  clear_has_referenceangle();
}
inline float CGRevoluteJointDef::referenceangle() const {
  return referenceangle_;
}
inline void CGRevoluteJointDef::set_referenceangle(float value) {
  set_has_referenceangle();
  referenceangle_ = value;
}

// optional bool enableLimit = 3;
inline bool CGRevoluteJointDef::has_enablelimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGRevoluteJointDef::set_has_enablelimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGRevoluteJointDef::clear_has_enablelimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGRevoluteJointDef::clear_enablelimit() {
  enablelimit_ = false;
  clear_has_enablelimit();
}
inline bool CGRevoluteJointDef::enablelimit() const {
  return enablelimit_;
}
inline void CGRevoluteJointDef::set_enablelimit(bool value) {
  set_has_enablelimit();
  enablelimit_ = value;
}

// optional float lowerAngle = 4;
inline bool CGRevoluteJointDef::has_lowerangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGRevoluteJointDef::set_has_lowerangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGRevoluteJointDef::clear_has_lowerangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGRevoluteJointDef::clear_lowerangle() {
  lowerangle_ = 0;
  clear_has_lowerangle();
}
inline float CGRevoluteJointDef::lowerangle() const {
  return lowerangle_;
}
inline void CGRevoluteJointDef::set_lowerangle(float value) {
  set_has_lowerangle();
  lowerangle_ = value;
}

// optional float upperAngle = 5;
inline bool CGRevoluteJointDef::has_upperangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGRevoluteJointDef::set_has_upperangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGRevoluteJointDef::clear_has_upperangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGRevoluteJointDef::clear_upperangle() {
  upperangle_ = 0;
  clear_has_upperangle();
}
inline float CGRevoluteJointDef::upperangle() const {
  return upperangle_;
}
inline void CGRevoluteJointDef::set_upperangle(float value) {
  set_has_upperangle();
  upperangle_ = value;
}

// optional bool enableMotor = 6;
inline bool CGRevoluteJointDef::has_enablemotor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGRevoluteJointDef::set_has_enablemotor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGRevoluteJointDef::clear_has_enablemotor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGRevoluteJointDef::clear_enablemotor() {
  enablemotor_ = false;
  clear_has_enablemotor();
}
inline bool CGRevoluteJointDef::enablemotor() const {
  return enablemotor_;
}
inline void CGRevoluteJointDef::set_enablemotor(bool value) {
  set_has_enablemotor();
  enablemotor_ = value;
}

// optional float motorSpeed = 7;
inline bool CGRevoluteJointDef::has_motorspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGRevoluteJointDef::set_has_motorspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGRevoluteJointDef::clear_has_motorspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGRevoluteJointDef::clear_motorspeed() {
  motorspeed_ = 0;
  clear_has_motorspeed();
}
inline float CGRevoluteJointDef::motorspeed() const {
  return motorspeed_;
}
inline void CGRevoluteJointDef::set_motorspeed(float value) {
  set_has_motorspeed();
  motorspeed_ = value;
}

// optional float maxMotorTorque = 8;
inline bool CGRevoluteJointDef::has_maxmotortorque() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGRevoluteJointDef::set_has_maxmotortorque() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGRevoluteJointDef::clear_has_maxmotortorque() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGRevoluteJointDef::clear_maxmotortorque() {
  maxmotortorque_ = 0;
  clear_has_maxmotortorque();
}
inline float CGRevoluteJointDef::maxmotortorque() const {
  return maxmotortorque_;
}
inline void CGRevoluteJointDef::set_maxmotortorque(float value) {
  set_has_maxmotortorque();
  maxmotortorque_ = value;
}

// -------------------------------------------------------------------

// CGPrismaticJointDef

// optional bool collideConnected = 1;
inline bool CGPrismaticJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGPrismaticJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGPrismaticJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGPrismaticJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGPrismaticJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGPrismaticJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional .com.laex.cg2d.model.CGVector2 anchor = 2;
inline bool CGPrismaticJointDef::has_anchor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGPrismaticJointDef::set_has_anchor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGPrismaticJointDef::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGPrismaticJointDef::clear_anchor() {
  if (anchor_ != NULL) anchor_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_anchor();
}
inline const ::com::laex::cg2d::model::CGVector2& CGPrismaticJointDef::anchor() const {
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPrismaticJointDef::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::com::laex::cg2d::model::CGVector2;
  return anchor_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPrismaticJointDef::release_anchor() {
  clear_has_anchor();
  ::com::laex::cg2d::model::CGVector2* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void CGPrismaticJointDef::set_allocated_anchor(::com::laex::cg2d::model::CGVector2* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
}

// optional .com.laex.cg2d.model.CGVector2 axis = 3;
inline bool CGPrismaticJointDef::has_axis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGPrismaticJointDef::set_has_axis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGPrismaticJointDef::clear_has_axis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGPrismaticJointDef::clear_axis() {
  if (axis_ != NULL) axis_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_axis();
}
inline const ::com::laex::cg2d::model::CGVector2& CGPrismaticJointDef::axis() const {
  return axis_ != NULL ? *axis_ : *default_instance_->axis_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPrismaticJointDef::mutable_axis() {
  set_has_axis();
  if (axis_ == NULL) axis_ = new ::com::laex::cg2d::model::CGVector2;
  return axis_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPrismaticJointDef::release_axis() {
  clear_has_axis();
  ::com::laex::cg2d::model::CGVector2* temp = axis_;
  axis_ = NULL;
  return temp;
}
inline void CGPrismaticJointDef::set_allocated_axis(::com::laex::cg2d::model::CGVector2* axis) {
  delete axis_;
  axis_ = axis;
  if (axis) {
    set_has_axis();
  } else {
    clear_has_axis();
  }
}

// optional float referenceAngle = 5;
inline bool CGPrismaticJointDef::has_referenceangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGPrismaticJointDef::set_has_referenceangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGPrismaticJointDef::clear_has_referenceangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGPrismaticJointDef::clear_referenceangle() {
  referenceangle_ = 0;
  clear_has_referenceangle();
}
inline float CGPrismaticJointDef::referenceangle() const {
  return referenceangle_;
}
inline void CGPrismaticJointDef::set_referenceangle(float value) {
  set_has_referenceangle();
  referenceangle_ = value;
}

// optional bool enableLimit = 6;
inline bool CGPrismaticJointDef::has_enablelimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGPrismaticJointDef::set_has_enablelimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGPrismaticJointDef::clear_has_enablelimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGPrismaticJointDef::clear_enablelimit() {
  enablelimit_ = false;
  clear_has_enablelimit();
}
inline bool CGPrismaticJointDef::enablelimit() const {
  return enablelimit_;
}
inline void CGPrismaticJointDef::set_enablelimit(bool value) {
  set_has_enablelimit();
  enablelimit_ = value;
}

// optional float lowerTranslation = 7;
inline bool CGPrismaticJointDef::has_lowertranslation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGPrismaticJointDef::set_has_lowertranslation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGPrismaticJointDef::clear_has_lowertranslation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGPrismaticJointDef::clear_lowertranslation() {
  lowertranslation_ = 0;
  clear_has_lowertranslation();
}
inline float CGPrismaticJointDef::lowertranslation() const {
  return lowertranslation_;
}
inline void CGPrismaticJointDef::set_lowertranslation(float value) {
  set_has_lowertranslation();
  lowertranslation_ = value;
}

// optional float upperTranslation = 8;
inline bool CGPrismaticJointDef::has_uppertranslation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGPrismaticJointDef::set_has_uppertranslation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGPrismaticJointDef::clear_has_uppertranslation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGPrismaticJointDef::clear_uppertranslation() {
  uppertranslation_ = 0;
  clear_has_uppertranslation();
}
inline float CGPrismaticJointDef::uppertranslation() const {
  return uppertranslation_;
}
inline void CGPrismaticJointDef::set_uppertranslation(float value) {
  set_has_uppertranslation();
  uppertranslation_ = value;
}

// optional bool enableMotor = 9;
inline bool CGPrismaticJointDef::has_enablemotor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGPrismaticJointDef::set_has_enablemotor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGPrismaticJointDef::clear_has_enablemotor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGPrismaticJointDef::clear_enablemotor() {
  enablemotor_ = false;
  clear_has_enablemotor();
}
inline bool CGPrismaticJointDef::enablemotor() const {
  return enablemotor_;
}
inline void CGPrismaticJointDef::set_enablemotor(bool value) {
  set_has_enablemotor();
  enablemotor_ = value;
}

// optional float maxMotorForce = 10;
inline bool CGPrismaticJointDef::has_maxmotorforce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CGPrismaticJointDef::set_has_maxmotorforce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CGPrismaticJointDef::clear_has_maxmotorforce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CGPrismaticJointDef::clear_maxmotorforce() {
  maxmotorforce_ = 0;
  clear_has_maxmotorforce();
}
inline float CGPrismaticJointDef::maxmotorforce() const {
  return maxmotorforce_;
}
inline void CGPrismaticJointDef::set_maxmotorforce(float value) {
  set_has_maxmotorforce();
  maxmotorforce_ = value;
}

// optional float motorSpeed = 11;
inline bool CGPrismaticJointDef::has_motorspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CGPrismaticJointDef::set_has_motorspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CGPrismaticJointDef::clear_has_motorspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CGPrismaticJointDef::clear_motorspeed() {
  motorspeed_ = 0;
  clear_has_motorspeed();
}
inline float CGPrismaticJointDef::motorspeed() const {
  return motorspeed_;
}
inline void CGPrismaticJointDef::set_motorspeed(float value) {
  set_has_motorspeed();
  motorspeed_ = value;
}

// -------------------------------------------------------------------

// CGPulleyJointDef

// optional bool collideConnected = 1;
inline bool CGPulleyJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGPulleyJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGPulleyJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGPulleyJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGPulleyJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGPulleyJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional .com.laex.cg2d.model.CGVector2 groundAnchorA = 2;
inline bool CGPulleyJointDef::has_groundanchora() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGPulleyJointDef::set_has_groundanchora() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGPulleyJointDef::clear_has_groundanchora() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGPulleyJointDef::clear_groundanchora() {
  if (groundanchora_ != NULL) groundanchora_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_groundanchora();
}
inline const ::com::laex::cg2d::model::CGVector2& CGPulleyJointDef::groundanchora() const {
  return groundanchora_ != NULL ? *groundanchora_ : *default_instance_->groundanchora_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPulleyJointDef::mutable_groundanchora() {
  set_has_groundanchora();
  if (groundanchora_ == NULL) groundanchora_ = new ::com::laex::cg2d::model::CGVector2;
  return groundanchora_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPulleyJointDef::release_groundanchora() {
  clear_has_groundanchora();
  ::com::laex::cg2d::model::CGVector2* temp = groundanchora_;
  groundanchora_ = NULL;
  return temp;
}
inline void CGPulleyJointDef::set_allocated_groundanchora(::com::laex::cg2d::model::CGVector2* groundanchora) {
  delete groundanchora_;
  groundanchora_ = groundanchora;
  if (groundanchora) {
    set_has_groundanchora();
  } else {
    clear_has_groundanchora();
  }
}

// optional .com.laex.cg2d.model.CGVector2 groundAnchorB = 3;
inline bool CGPulleyJointDef::has_groundanchorb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGPulleyJointDef::set_has_groundanchorb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGPulleyJointDef::clear_has_groundanchorb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGPulleyJointDef::clear_groundanchorb() {
  if (groundanchorb_ != NULL) groundanchorb_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_groundanchorb();
}
inline const ::com::laex::cg2d::model::CGVector2& CGPulleyJointDef::groundanchorb() const {
  return groundanchorb_ != NULL ? *groundanchorb_ : *default_instance_->groundanchorb_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPulleyJointDef::mutable_groundanchorb() {
  set_has_groundanchorb();
  if (groundanchorb_ == NULL) groundanchorb_ = new ::com::laex::cg2d::model::CGVector2;
  return groundanchorb_;
}
inline ::com::laex::cg2d::model::CGVector2* CGPulleyJointDef::release_groundanchorb() {
  clear_has_groundanchorb();
  ::com::laex::cg2d::model::CGVector2* temp = groundanchorb_;
  groundanchorb_ = NULL;
  return temp;
}
inline void CGPulleyJointDef::set_allocated_groundanchorb(::com::laex::cg2d::model::CGVector2* groundanchorb) {
  delete groundanchorb_;
  groundanchorb_ = groundanchorb;
  if (groundanchorb) {
    set_has_groundanchorb();
  } else {
    clear_has_groundanchorb();
  }
}

// optional float ratio = 4;
inline bool CGPulleyJointDef::has_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGPulleyJointDef::set_has_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGPulleyJointDef::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGPulleyJointDef::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline float CGPulleyJointDef::ratio() const {
  return ratio_;
}
inline void CGPulleyJointDef::set_ratio(float value) {
  set_has_ratio();
  ratio_ = value;
}

// -------------------------------------------------------------------

// CGFrictionJointDef

// optional bool collideConnected = 1;
inline bool CGFrictionJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGFrictionJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGFrictionJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGFrictionJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGFrictionJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGFrictionJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional float maxForce = 2;
inline bool CGFrictionJointDef::has_maxforce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGFrictionJointDef::set_has_maxforce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGFrictionJointDef::clear_has_maxforce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGFrictionJointDef::clear_maxforce() {
  maxforce_ = 0;
  clear_has_maxforce();
}
inline float CGFrictionJointDef::maxforce() const {
  return maxforce_;
}
inline void CGFrictionJointDef::set_maxforce(float value) {
  set_has_maxforce();
  maxforce_ = value;
}

// optional float maxTorque = 3;
inline bool CGFrictionJointDef::has_maxtorque() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGFrictionJointDef::set_has_maxtorque() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGFrictionJointDef::clear_has_maxtorque() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGFrictionJointDef::clear_maxtorque() {
  maxtorque_ = 0;
  clear_has_maxtorque();
}
inline float CGFrictionJointDef::maxtorque() const {
  return maxtorque_;
}
inline void CGFrictionJointDef::set_maxtorque(float value) {
  set_has_maxtorque();
  maxtorque_ = value;
}

// -------------------------------------------------------------------

// CGWeldJointDef

// optional bool collideConnected = 1;
inline bool CGWeldJointDef::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGWeldJointDef::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGWeldJointDef::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGWeldJointDef::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool CGWeldJointDef::collideconnected() const {
  return collideconnected_;
}
inline void CGWeldJointDef::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// -------------------------------------------------------------------

// CGResourceFile

// optional string resourceFile = 1;
inline bool CGResourceFile::has_resourcefile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGResourceFile::set_has_resourcefile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGResourceFile::clear_has_resourcefile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGResourceFile::clear_resourcefile() {
  if (resourcefile_ != &::google::protobuf::internal::kEmptyString) {
    resourcefile_->clear();
  }
  clear_has_resourcefile();
}
inline const ::std::string& CGResourceFile::resourcefile() const {
  return *resourcefile_;
}
inline void CGResourceFile::set_resourcefile(const ::std::string& value) {
  set_has_resourcefile();
  if (resourcefile_ == &::google::protobuf::internal::kEmptyString) {
    resourcefile_ = new ::std::string;
  }
  resourcefile_->assign(value);
}
inline void CGResourceFile::set_resourcefile(const char* value) {
  set_has_resourcefile();
  if (resourcefile_ == &::google::protobuf::internal::kEmptyString) {
    resourcefile_ = new ::std::string;
  }
  resourcefile_->assign(value);
}
inline void CGResourceFile::set_resourcefile(const char* value, size_t size) {
  set_has_resourcefile();
  if (resourcefile_ == &::google::protobuf::internal::kEmptyString) {
    resourcefile_ = new ::std::string;
  }
  resourcefile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGResourceFile::mutable_resourcefile() {
  set_has_resourcefile();
  if (resourcefile_ == &::google::protobuf::internal::kEmptyString) {
    resourcefile_ = new ::std::string;
  }
  return resourcefile_;
}
inline ::std::string* CGResourceFile::release_resourcefile() {
  clear_has_resourcefile();
  if (resourcefile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resourcefile_;
    resourcefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGResourceFile::set_allocated_resourcefile(::std::string* resourcefile) {
  if (resourcefile_ != &::google::protobuf::internal::kEmptyString) {
    delete resourcefile_;
  }
  if (resourcefile) {
    set_has_resourcefile();
    resourcefile_ = resourcefile;
  } else {
    clear_has_resourcefile();
    resourcefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resourceFileAbsolute = 2;
inline bool CGResourceFile::has_resourcefileabsolute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGResourceFile::set_has_resourcefileabsolute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGResourceFile::clear_has_resourcefileabsolute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGResourceFile::clear_resourcefileabsolute() {
  if (resourcefileabsolute_ != &::google::protobuf::internal::kEmptyString) {
    resourcefileabsolute_->clear();
  }
  clear_has_resourcefileabsolute();
}
inline const ::std::string& CGResourceFile::resourcefileabsolute() const {
  return *resourcefileabsolute_;
}
inline void CGResourceFile::set_resourcefileabsolute(const ::std::string& value) {
  set_has_resourcefileabsolute();
  if (resourcefileabsolute_ == &::google::protobuf::internal::kEmptyString) {
    resourcefileabsolute_ = new ::std::string;
  }
  resourcefileabsolute_->assign(value);
}
inline void CGResourceFile::set_resourcefileabsolute(const char* value) {
  set_has_resourcefileabsolute();
  if (resourcefileabsolute_ == &::google::protobuf::internal::kEmptyString) {
    resourcefileabsolute_ = new ::std::string;
  }
  resourcefileabsolute_->assign(value);
}
inline void CGResourceFile::set_resourcefileabsolute(const char* value, size_t size) {
  set_has_resourcefileabsolute();
  if (resourcefileabsolute_ == &::google::protobuf::internal::kEmptyString) {
    resourcefileabsolute_ = new ::std::string;
  }
  resourcefileabsolute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGResourceFile::mutable_resourcefileabsolute() {
  set_has_resourcefileabsolute();
  if (resourcefileabsolute_ == &::google::protobuf::internal::kEmptyString) {
    resourcefileabsolute_ = new ::std::string;
  }
  return resourcefileabsolute_;
}
inline ::std::string* CGResourceFile::release_resourcefileabsolute() {
  clear_has_resourcefileabsolute();
  if (resourcefileabsolute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resourcefileabsolute_;
    resourcefileabsolute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGResourceFile::set_allocated_resourcefileabsolute(::std::string* resourcefileabsolute) {
  if (resourcefileabsolute_ != &::google::protobuf::internal::kEmptyString) {
    delete resourcefileabsolute_;
  }
  if (resourcefileabsolute) {
    set_has_resourcefileabsolute();
    resourcefileabsolute_ = resourcefileabsolute;
  } else {
    clear_has_resourcefileabsolute();
    resourcefileabsolute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGEntitySpritesheetItem

// optional .com.laex.cg2d.model.CGBounds extractBounds = 1;
inline bool CGEntitySpritesheetItem::has_extractbounds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGEntitySpritesheetItem::set_has_extractbounds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGEntitySpritesheetItem::clear_has_extractbounds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGEntitySpritesheetItem::clear_extractbounds() {
  if (extractbounds_ != NULL) extractbounds_->::com::laex::cg2d::model::CGBounds::Clear();
  clear_has_extractbounds();
}
inline const ::com::laex::cg2d::model::CGBounds& CGEntitySpritesheetItem::extractbounds() const {
  return extractbounds_ != NULL ? *extractbounds_ : *default_instance_->extractbounds_;
}
inline ::com::laex::cg2d::model::CGBounds* CGEntitySpritesheetItem::mutable_extractbounds() {
  set_has_extractbounds();
  if (extractbounds_ == NULL) extractbounds_ = new ::com::laex::cg2d::model::CGBounds;
  return extractbounds_;
}
inline ::com::laex::cg2d::model::CGBounds* CGEntitySpritesheetItem::release_extractbounds() {
  clear_has_extractbounds();
  ::com::laex::cg2d::model::CGBounds* temp = extractbounds_;
  extractbounds_ = NULL;
  return temp;
}
inline void CGEntitySpritesheetItem::set_allocated_extractbounds(::com::laex::cg2d::model::CGBounds* extractbounds) {
  delete extractbounds_;
  extractbounds_ = extractbounds;
  if (extractbounds) {
    set_has_extractbounds();
  } else {
    clear_has_extractbounds();
  }
}

// optional int32 frameIndex = 2;
inline bool CGEntitySpritesheetItem::has_frameindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGEntitySpritesheetItem::set_has_frameindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGEntitySpritesheetItem::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGEntitySpritesheetItem::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 CGEntitySpritesheetItem::frameindex() const {
  return frameindex_;
}
inline void CGEntitySpritesheetItem::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// -------------------------------------------------------------------

// CGEntityAnimation

// optional string animationName = 1;
inline bool CGEntityAnimation::has_animationname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGEntityAnimation::set_has_animationname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGEntityAnimation::clear_has_animationname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGEntityAnimation::clear_animationname() {
  if (animationname_ != &::google::protobuf::internal::kEmptyString) {
    animationname_->clear();
  }
  clear_has_animationname();
}
inline const ::std::string& CGEntityAnimation::animationname() const {
  return *animationname_;
}
inline void CGEntityAnimation::set_animationname(const ::std::string& value) {
  set_has_animationname();
  if (animationname_ == &::google::protobuf::internal::kEmptyString) {
    animationname_ = new ::std::string;
  }
  animationname_->assign(value);
}
inline void CGEntityAnimation::set_animationname(const char* value) {
  set_has_animationname();
  if (animationname_ == &::google::protobuf::internal::kEmptyString) {
    animationname_ = new ::std::string;
  }
  animationname_->assign(value);
}
inline void CGEntityAnimation::set_animationname(const char* value, size_t size) {
  set_has_animationname();
  if (animationname_ == &::google::protobuf::internal::kEmptyString) {
    animationname_ = new ::std::string;
  }
  animationname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGEntityAnimation::mutable_animationname() {
  set_has_animationname();
  if (animationname_ == &::google::protobuf::internal::kEmptyString) {
    animationname_ = new ::std::string;
  }
  return animationname_;
}
inline ::std::string* CGEntityAnimation::release_animationname() {
  clear_has_animationname();
  if (animationname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = animationname_;
    animationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGEntityAnimation::set_allocated_animationname(::std::string* animationname) {
  if (animationname_ != &::google::protobuf::internal::kEmptyString) {
    delete animationname_;
  }
  if (animationname) {
    set_has_animationname();
    animationname_ = animationname;
  } else {
    clear_has_animationname();
    animationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float animationDuration = 2;
inline bool CGEntityAnimation::has_animationduration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGEntityAnimation::set_has_animationduration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGEntityAnimation::clear_has_animationduration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGEntityAnimation::clear_animationduration() {
  animationduration_ = 0;
  clear_has_animationduration();
}
inline float CGEntityAnimation::animationduration() const {
  return animationduration_;
}
inline void CGEntityAnimation::set_animationduration(float value) {
  set_has_animationduration();
  animationduration_ = value;
}

// optional bool defaultAnimation = 3;
inline bool CGEntityAnimation::has_defaultanimation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGEntityAnimation::set_has_defaultanimation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGEntityAnimation::clear_has_defaultanimation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGEntityAnimation::clear_defaultanimation() {
  defaultanimation_ = false;
  clear_has_defaultanimation();
}
inline bool CGEntityAnimation::defaultanimation() const {
  return defaultanimation_;
}
inline void CGEntityAnimation::set_defaultanimation(bool value) {
  set_has_defaultanimation();
  defaultanimation_ = value;
}

// optional .com.laex.cg2d.model.CGEntityCollisionType collisionType = 4;
inline bool CGEntityAnimation::has_collisiontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGEntityAnimation::set_has_collisiontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGEntityAnimation::clear_has_collisiontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGEntityAnimation::clear_collisiontype() {
  collisiontype_ = 0;
  clear_has_collisiontype();
}
inline ::com::laex::cg2d::model::CGEntityCollisionType CGEntityAnimation::collisiontype() const {
  return static_cast< ::com::laex::cg2d::model::CGEntityCollisionType >(collisiontype_);
}
inline void CGEntityAnimation::set_collisiontype(::com::laex::cg2d::model::CGEntityCollisionType value) {
  assert(::com::laex::cg2d::model::CGEntityCollisionType_IsValid(value));
  set_has_collisiontype();
  collisiontype_ = value;
}

// optional .com.laex.cg2d.model.CGResourceFile spritesheetFile = 5;
inline bool CGEntityAnimation::has_spritesheetfile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGEntityAnimation::set_has_spritesheetfile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGEntityAnimation::clear_has_spritesheetfile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGEntityAnimation::clear_spritesheetfile() {
  if (spritesheetfile_ != NULL) spritesheetfile_->::com::laex::cg2d::model::CGResourceFile::Clear();
  clear_has_spritesheetfile();
}
inline const ::com::laex::cg2d::model::CGResourceFile& CGEntityAnimation::spritesheetfile() const {
  return spritesheetfile_ != NULL ? *spritesheetfile_ : *default_instance_->spritesheetfile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::mutable_spritesheetfile() {
  set_has_spritesheetfile();
  if (spritesheetfile_ == NULL) spritesheetfile_ = new ::com::laex::cg2d::model::CGResourceFile;
  return spritesheetfile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::release_spritesheetfile() {
  clear_has_spritesheetfile();
  ::com::laex::cg2d::model::CGResourceFile* temp = spritesheetfile_;
  spritesheetfile_ = NULL;
  return temp;
}
inline void CGEntityAnimation::set_allocated_spritesheetfile(::com::laex::cg2d::model::CGResourceFile* spritesheetfile) {
  delete spritesheetfile_;
  spritesheetfile_ = spritesheetfile;
  if (spritesheetfile) {
    set_has_spritesheetfile();
  } else {
    clear_has_spritesheetfile();
  }
}

// optional .com.laex.cg2d.model.CGResourceFile spritesheetJsonFile = 6;
inline bool CGEntityAnimation::has_spritesheetjsonfile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGEntityAnimation::set_has_spritesheetjsonfile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGEntityAnimation::clear_has_spritesheetjsonfile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGEntityAnimation::clear_spritesheetjsonfile() {
  if (spritesheetjsonfile_ != NULL) spritesheetjsonfile_->::com::laex::cg2d::model::CGResourceFile::Clear();
  clear_has_spritesheetjsonfile();
}
inline const ::com::laex::cg2d::model::CGResourceFile& CGEntityAnimation::spritesheetjsonfile() const {
  return spritesheetjsonfile_ != NULL ? *spritesheetjsonfile_ : *default_instance_->spritesheetjsonfile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::mutable_spritesheetjsonfile() {
  set_has_spritesheetjsonfile();
  if (spritesheetjsonfile_ == NULL) spritesheetjsonfile_ = new ::com::laex::cg2d::model::CGResourceFile;
  return spritesheetjsonfile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::release_spritesheetjsonfile() {
  clear_has_spritesheetjsonfile();
  ::com::laex::cg2d::model::CGResourceFile* temp = spritesheetjsonfile_;
  spritesheetjsonfile_ = NULL;
  return temp;
}
inline void CGEntityAnimation::set_allocated_spritesheetjsonfile(::com::laex::cg2d::model::CGResourceFile* spritesheetjsonfile) {
  delete spritesheetjsonfile_;
  spritesheetjsonfile_ = spritesheetjsonfile;
  if (spritesheetjsonfile) {
    set_has_spritesheetjsonfile();
  } else {
    clear_has_spritesheetjsonfile();
  }
}

// optional .com.laex.cg2d.model.CGResourceFile fixtureFile = 7;
inline bool CGEntityAnimation::has_fixturefile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGEntityAnimation::set_has_fixturefile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGEntityAnimation::clear_has_fixturefile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGEntityAnimation::clear_fixturefile() {
  if (fixturefile_ != NULL) fixturefile_->::com::laex::cg2d::model::CGResourceFile::Clear();
  clear_has_fixturefile();
}
inline const ::com::laex::cg2d::model::CGResourceFile& CGEntityAnimation::fixturefile() const {
  return fixturefile_ != NULL ? *fixturefile_ : *default_instance_->fixturefile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::mutable_fixturefile() {
  set_has_fixturefile();
  if (fixturefile_ == NULL) fixturefile_ = new ::com::laex::cg2d::model::CGResourceFile;
  return fixturefile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGEntityAnimation::release_fixturefile() {
  clear_has_fixturefile();
  ::com::laex::cg2d::model::CGResourceFile* temp = fixturefile_;
  fixturefile_ = NULL;
  return temp;
}
inline void CGEntityAnimation::set_allocated_fixturefile(::com::laex::cg2d::model::CGResourceFile* fixturefile) {
  delete fixturefile_;
  fixturefile_ = fixturefile;
  if (fixturefile) {
    set_has_fixturefile();
  } else {
    clear_has_fixturefile();
  }
}

// repeated .com.laex.cg2d.model.CGVector2 vertices = 8;
inline int CGEntityAnimation::vertices_size() const {
  return vertices_.size();
}
inline void CGEntityAnimation::clear_vertices() {
  vertices_.Clear();
}
inline const ::com::laex::cg2d::model::CGVector2& CGEntityAnimation::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::com::laex::cg2d::model::CGVector2* CGEntityAnimation::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGVector2* CGEntityAnimation::add_vertices() {
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGVector2 >&
CGEntityAnimation::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGVector2 >*
CGEntityAnimation::mutable_vertices() {
  return &vertices_;
}

// repeated .com.laex.cg2d.model.CGEntitySpritesheetItem spritesheetItems = 9;
inline int CGEntityAnimation::spritesheetitems_size() const {
  return spritesheetitems_.size();
}
inline void CGEntityAnimation::clear_spritesheetitems() {
  spritesheetitems_.Clear();
}
inline const ::com::laex::cg2d::model::CGEntitySpritesheetItem& CGEntityAnimation::spritesheetitems(int index) const {
  return spritesheetitems_.Get(index);
}
inline ::com::laex::cg2d::model::CGEntitySpritesheetItem* CGEntityAnimation::mutable_spritesheetitems(int index) {
  return spritesheetitems_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGEntitySpritesheetItem* CGEntityAnimation::add_spritesheetitems() {
  return spritesheetitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntitySpritesheetItem >&
CGEntityAnimation::spritesheetitems() const {
  return spritesheetitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntitySpritesheetItem >*
CGEntityAnimation::mutable_spritesheetitems() {
  return &spritesheetitems_;
}

// -------------------------------------------------------------------

// CGEntity

// repeated .com.laex.cg2d.model.CGEntityAnimation animations = 1;
inline int CGEntity::animations_size() const {
  return animations_.size();
}
inline void CGEntity::clear_animations() {
  animations_.Clear();
}
inline const ::com::laex::cg2d::model::CGEntityAnimation& CGEntity::animations(int index) const {
  return animations_.Get(index);
}
inline ::com::laex::cg2d::model::CGEntityAnimation* CGEntity::mutable_animations(int index) {
  return animations_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGEntityAnimation* CGEntity::add_animations() {
  return animations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntityAnimation >&
CGEntity::animations() const {
  return animations_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGEntityAnimation >*
CGEntity::mutable_animations() {
  return &animations_;
}

// -------------------------------------------------------------------

// CGBounds

// optional float x = 1;
inline bool CGBounds::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGBounds::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGBounds::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGBounds::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float CGBounds::x() const {
  return x_;
}
inline void CGBounds::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool CGBounds::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGBounds::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGBounds::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGBounds::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float CGBounds::y() const {
  return y_;
}
inline void CGBounds::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float width = 3;
inline bool CGBounds::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGBounds::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGBounds::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGBounds::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float CGBounds::width() const {
  return width_;
}
inline void CGBounds::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 4;
inline bool CGBounds::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGBounds::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGBounds::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGBounds::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CGBounds::height() const {
  return height_;
}
inline void CGBounds::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// CGVector2

// required float x = 1;
inline bool CGVector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGVector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGVector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGVector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float CGVector2::x() const {
  return x_;
}
inline void CGVector2::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool CGVector2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGVector2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGVector2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGVector2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float CGVector2::y() const {
  return y_;
}
inline void CGVector2::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// CGColor

// required int32 r = 1;
inline bool CGColor::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGColor::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGColor::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGColor::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 CGColor::r() const {
  return r_;
}
inline void CGColor::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// required int32 g = 2;
inline bool CGColor::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGColor::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGColor::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGColor::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline ::google::protobuf::int32 CGColor::g() const {
  return g_;
}
inline void CGColor::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
}

// required int32 b = 3;
inline bool CGColor::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGColor::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGColor::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGColor::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 CGColor::b() const {
  return b_;
}
inline void CGColor::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
}

// -------------------------------------------------------------------

// CGBodyDef

// optional bool active = 1;
inline bool CGBodyDef::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGBodyDef::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGBodyDef::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGBodyDef::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool CGBodyDef::active() const {
  return active_;
}
inline void CGBodyDef::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional bool allowSleep = 2;
inline bool CGBodyDef::has_allowsleep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGBodyDef::set_has_allowsleep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGBodyDef::clear_has_allowsleep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGBodyDef::clear_allowsleep() {
  allowsleep_ = false;
  clear_has_allowsleep();
}
inline bool CGBodyDef::allowsleep() const {
  return allowsleep_;
}
inline void CGBodyDef::set_allowsleep(bool value) {
  set_has_allowsleep();
  allowsleep_ = value;
}

// optional float angle = 3;
inline bool CGBodyDef::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGBodyDef::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGBodyDef::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGBodyDef::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float CGBodyDef::angle() const {
  return angle_;
}
inline void CGBodyDef::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float angularDamping = 4;
inline bool CGBodyDef::has_angulardamping() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGBodyDef::set_has_angulardamping() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGBodyDef::clear_has_angulardamping() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGBodyDef::clear_angulardamping() {
  angulardamping_ = 0;
  clear_has_angulardamping();
}
inline float CGBodyDef::angulardamping() const {
  return angulardamping_;
}
inline void CGBodyDef::set_angulardamping(float value) {
  set_has_angulardamping();
  angulardamping_ = value;
}

// optional float angularVelocity = 5;
inline bool CGBodyDef::has_angularvelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGBodyDef::set_has_angularvelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGBodyDef::clear_has_angularvelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGBodyDef::clear_angularvelocity() {
  angularvelocity_ = 0;
  clear_has_angularvelocity();
}
inline float CGBodyDef::angularvelocity() const {
  return angularvelocity_;
}
inline void CGBodyDef::set_angularvelocity(float value) {
  set_has_angularvelocity();
  angularvelocity_ = value;
}

// optional bool awake = 6;
inline bool CGBodyDef::has_awake() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGBodyDef::set_has_awake() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGBodyDef::clear_has_awake() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGBodyDef::clear_awake() {
  awake_ = false;
  clear_has_awake();
}
inline bool CGBodyDef::awake() const {
  return awake_;
}
inline void CGBodyDef::set_awake(bool value) {
  set_has_awake();
  awake_ = value;
}

// optional bool bullet = 7;
inline bool CGBodyDef::has_bullet() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGBodyDef::set_has_bullet() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGBodyDef::clear_has_bullet() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGBodyDef::clear_bullet() {
  bullet_ = false;
  clear_has_bullet();
}
inline bool CGBodyDef::bullet() const {
  return bullet_;
}
inline void CGBodyDef::set_bullet(bool value) {
  set_has_bullet();
  bullet_ = value;
}

// optional bool fixedRotation = 8;
inline bool CGBodyDef::has_fixedrotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGBodyDef::set_has_fixedrotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGBodyDef::clear_has_fixedrotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGBodyDef::clear_fixedrotation() {
  fixedrotation_ = false;
  clear_has_fixedrotation();
}
inline bool CGBodyDef::fixedrotation() const {
  return fixedrotation_;
}
inline void CGBodyDef::set_fixedrotation(bool value) {
  set_has_fixedrotation();
  fixedrotation_ = value;
}

// optional float intertialScale = 9;
inline bool CGBodyDef::has_intertialscale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CGBodyDef::set_has_intertialscale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CGBodyDef::clear_has_intertialscale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CGBodyDef::clear_intertialscale() {
  intertialscale_ = 0;
  clear_has_intertialscale();
}
inline float CGBodyDef::intertialscale() const {
  return intertialscale_;
}
inline void CGBodyDef::set_intertialscale(float value) {
  set_has_intertialscale();
  intertialscale_ = value;
}

// optional float linearDamping = 10;
inline bool CGBodyDef::has_lineardamping() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CGBodyDef::set_has_lineardamping() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CGBodyDef::clear_has_lineardamping() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CGBodyDef::clear_lineardamping() {
  lineardamping_ = 0;
  clear_has_lineardamping();
}
inline float CGBodyDef::lineardamping() const {
  return lineardamping_;
}
inline void CGBodyDef::set_lineardamping(float value) {
  set_has_lineardamping();
  lineardamping_ = value;
}

// optional float gravityScale = 11;
inline bool CGBodyDef::has_gravityscale() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CGBodyDef::set_has_gravityscale() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CGBodyDef::clear_has_gravityscale() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CGBodyDef::clear_gravityscale() {
  gravityscale_ = 0;
  clear_has_gravityscale();
}
inline float CGBodyDef::gravityscale() const {
  return gravityscale_;
}
inline void CGBodyDef::set_gravityscale(float value) {
  set_has_gravityscale();
  gravityscale_ = value;
}

// optional .com.laex.cg2d.model.CGVector2 linearVelocity = 12;
inline bool CGBodyDef::has_linearvelocity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CGBodyDef::set_has_linearvelocity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CGBodyDef::clear_has_linearvelocity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CGBodyDef::clear_linearvelocity() {
  if (linearvelocity_ != NULL) linearvelocity_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_linearvelocity();
}
inline const ::com::laex::cg2d::model::CGVector2& CGBodyDef::linearvelocity() const {
  return linearvelocity_ != NULL ? *linearvelocity_ : *default_instance_->linearvelocity_;
}
inline ::com::laex::cg2d::model::CGVector2* CGBodyDef::mutable_linearvelocity() {
  set_has_linearvelocity();
  if (linearvelocity_ == NULL) linearvelocity_ = new ::com::laex::cg2d::model::CGVector2;
  return linearvelocity_;
}
inline ::com::laex::cg2d::model::CGVector2* CGBodyDef::release_linearvelocity() {
  clear_has_linearvelocity();
  ::com::laex::cg2d::model::CGVector2* temp = linearvelocity_;
  linearvelocity_ = NULL;
  return temp;
}
inline void CGBodyDef::set_allocated_linearvelocity(::com::laex::cg2d::model::CGVector2* linearvelocity) {
  delete linearvelocity_;
  linearvelocity_ = linearvelocity;
  if (linearvelocity) {
    set_has_linearvelocity();
  } else {
    clear_has_linearvelocity();
  }
}

// optional .com.laex.cg2d.model.CGBodyType type = 13;
inline bool CGBodyDef::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CGBodyDef::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CGBodyDef::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CGBodyDef::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::laex::cg2d::model::CGBodyType CGBodyDef::type() const {
  return static_cast< ::com::laex::cg2d::model::CGBodyType >(type_);
}
inline void CGBodyDef::set_type(::com::laex::cg2d::model::CGBodyType value) {
  assert(::com::laex::cg2d::model::CGBodyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .com.laex.cg2d.model.CGVector2 position = 14;
inline bool CGBodyDef::has_position() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CGBodyDef::set_has_position() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CGBodyDef::clear_has_position() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CGBodyDef::clear_position() {
  if (position_ != NULL) position_->::com::laex::cg2d::model::CGVector2::Clear();
  clear_has_position();
}
inline const ::com::laex::cg2d::model::CGVector2& CGBodyDef::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::com::laex::cg2d::model::CGVector2* CGBodyDef::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::com::laex::cg2d::model::CGVector2;
  return position_;
}
inline ::com::laex::cg2d::model::CGVector2* CGBodyDef::release_position() {
  clear_has_position();
  ::com::laex::cg2d::model::CGVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CGBodyDef::set_allocated_position(::com::laex::cg2d::model::CGVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// -------------------------------------------------------------------

// CGFilter

// optional int32 categoryBits = 1;
inline bool CGFilter::has_categorybits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGFilter::set_has_categorybits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGFilter::clear_has_categorybits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGFilter::clear_categorybits() {
  categorybits_ = 0;
  clear_has_categorybits();
}
inline ::google::protobuf::int32 CGFilter::categorybits() const {
  return categorybits_;
}
inline void CGFilter::set_categorybits(::google::protobuf::int32 value) {
  set_has_categorybits();
  categorybits_ = value;
}

// optional int32 maskBits = 2;
inline bool CGFilter::has_maskbits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGFilter::set_has_maskbits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGFilter::clear_has_maskbits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGFilter::clear_maskbits() {
  maskbits_ = 0;
  clear_has_maskbits();
}
inline ::google::protobuf::int32 CGFilter::maskbits() const {
  return maskbits_;
}
inline void CGFilter::set_maskbits(::google::protobuf::int32 value) {
  set_has_maskbits();
  maskbits_ = value;
}

// optional int32 groupIndex = 3;
inline bool CGFilter::has_groupindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGFilter::set_has_groupindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGFilter::clear_has_groupindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGFilter::clear_groupindex() {
  groupindex_ = 0;
  clear_has_groupindex();
}
inline ::google::protobuf::int32 CGFilter::groupindex() const {
  return groupindex_;
}
inline void CGFilter::set_groupindex(::google::protobuf::int32 value) {
  set_has_groupindex();
  groupindex_ = value;
}

// -------------------------------------------------------------------

// CGFixtureDef

// optional float density = 1;
inline bool CGFixtureDef::has_density() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGFixtureDef::set_has_density() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGFixtureDef::clear_has_density() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGFixtureDef::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float CGFixtureDef::density() const {
  return density_;
}
inline void CGFixtureDef::set_density(float value) {
  set_has_density();
  density_ = value;
}

// optional float friction = 2;
inline bool CGFixtureDef::has_friction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGFixtureDef::set_has_friction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGFixtureDef::clear_has_friction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGFixtureDef::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline float CGFixtureDef::friction() const {
  return friction_;
}
inline void CGFixtureDef::set_friction(float value) {
  set_has_friction();
  friction_ = value;
}

// optional float restitution = 3;
inline bool CGFixtureDef::has_restitution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGFixtureDef::set_has_restitution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGFixtureDef::clear_has_restitution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGFixtureDef::clear_restitution() {
  restitution_ = 0;
  clear_has_restitution();
}
inline float CGFixtureDef::restitution() const {
  return restitution_;
}
inline void CGFixtureDef::set_restitution(float value) {
  set_has_restitution();
  restitution_ = value;
}

// optional bool sensor = 4;
inline bool CGFixtureDef::has_sensor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGFixtureDef::set_has_sensor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGFixtureDef::clear_has_sensor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGFixtureDef::clear_sensor() {
  sensor_ = false;
  clear_has_sensor();
}
inline bool CGFixtureDef::sensor() const {
  return sensor_;
}
inline void CGFixtureDef::set_sensor(bool value) {
  set_has_sensor();
  sensor_ = value;
}

// optional .com.laex.cg2d.model.CGFilter filter = 5;
inline bool CGFixtureDef::has_filter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGFixtureDef::set_has_filter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGFixtureDef::clear_has_filter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGFixtureDef::clear_filter() {
  if (filter_ != NULL) filter_->::com::laex::cg2d::model::CGFilter::Clear();
  clear_has_filter();
}
inline const ::com::laex::cg2d::model::CGFilter& CGFixtureDef::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::com::laex::cg2d::model::CGFilter* CGFixtureDef::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::com::laex::cg2d::model::CGFilter;
  return filter_;
}
inline ::com::laex::cg2d::model::CGFilter* CGFixtureDef::release_filter() {
  clear_has_filter();
  ::com::laex::cg2d::model::CGFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void CGFixtureDef::set_allocated_filter(::com::laex::cg2d::model::CGFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// -------------------------------------------------------------------

// CGShape

// optional string id = 1;
inline bool CGShape::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGShape::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGShape::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGShape::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CGShape::id() const {
  return *id_;
}
inline void CGShape::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGShape::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGShape::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGShape::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CGShape::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGShape::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool visible = 2;
inline bool CGShape::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGShape::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGShape::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGShape::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CGShape::visible() const {
  return visible_;
}
inline void CGShape::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional bool locked = 3;
inline bool CGShape::has_locked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGShape::set_has_locked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGShape::clear_has_locked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGShape::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool CGShape::locked() const {
  return locked_;
}
inline void CGShape::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// optional bool background = 4;
inline bool CGShape::has_background() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGShape::set_has_background() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGShape::clear_has_background() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGShape::clear_background() {
  background_ = false;
  clear_has_background();
}
inline bool CGShape::background() const {
  return background_;
}
inline void CGShape::set_background(bool value) {
  set_has_background();
  background_ = value;
}

// optional .com.laex.cg2d.model.CGResourceFile backgroundResourceFile = 5;
inline bool CGShape::has_backgroundresourcefile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGShape::set_has_backgroundresourcefile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGShape::clear_has_backgroundresourcefile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGShape::clear_backgroundresourcefile() {
  if (backgroundresourcefile_ != NULL) backgroundresourcefile_->::com::laex::cg2d::model::CGResourceFile::Clear();
  clear_has_backgroundresourcefile();
}
inline const ::com::laex::cg2d::model::CGResourceFile& CGShape::backgroundresourcefile() const {
  return backgroundresourcefile_ != NULL ? *backgroundresourcefile_ : *default_instance_->backgroundresourcefile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGShape::mutable_backgroundresourcefile() {
  set_has_backgroundresourcefile();
  if (backgroundresourcefile_ == NULL) backgroundresourcefile_ = new ::com::laex::cg2d::model::CGResourceFile;
  return backgroundresourcefile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGShape::release_backgroundresourcefile() {
  clear_has_backgroundresourcefile();
  ::com::laex::cg2d::model::CGResourceFile* temp = backgroundresourcefile_;
  backgroundresourcefile_ = NULL;
  return temp;
}
inline void CGShape::set_allocated_backgroundresourcefile(::com::laex::cg2d::model::CGResourceFile* backgroundresourcefile) {
  delete backgroundresourcefile_;
  backgroundresourcefile_ = backgroundresourcefile;
  if (backgroundresourcefile) {
    set_has_backgroundresourcefile();
  } else {
    clear_has_backgroundresourcefile();
  }
}

// optional .com.laex.cg2d.model.CGEditorShapeType editorShapeType = 6;
inline bool CGShape::has_editorshapetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGShape::set_has_editorshapetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGShape::clear_has_editorshapetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGShape::clear_editorshapetype() {
  editorshapetype_ = 1;
  clear_has_editorshapetype();
}
inline ::com::laex::cg2d::model::CGEditorShapeType CGShape::editorshapetype() const {
  return static_cast< ::com::laex::cg2d::model::CGEditorShapeType >(editorshapetype_);
}
inline void CGShape::set_editorshapetype(::com::laex::cg2d::model::CGEditorShapeType value) {
  assert(::com::laex::cg2d::model::CGEditorShapeType_IsValid(value));
  set_has_editorshapetype();
  editorshapetype_ = value;
}

// optional .com.laex.cg2d.model.CGBounds bounds = 7;
inline bool CGShape::has_bounds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGShape::set_has_bounds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGShape::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGShape::clear_bounds() {
  if (bounds_ != NULL) bounds_->::com::laex::cg2d::model::CGBounds::Clear();
  clear_has_bounds();
}
inline const ::com::laex::cg2d::model::CGBounds& CGShape::bounds() const {
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
}
inline ::com::laex::cg2d::model::CGBounds* CGShape::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::com::laex::cg2d::model::CGBounds;
  return bounds_;
}
inline ::com::laex::cg2d::model::CGBounds* CGShape::release_bounds() {
  clear_has_bounds();
  ::com::laex::cg2d::model::CGBounds* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline void CGShape::set_allocated_bounds(::com::laex::cg2d::model::CGBounds* bounds) {
  delete bounds_;
  bounds_ = bounds;
  if (bounds) {
    set_has_bounds();
  } else {
    clear_has_bounds();
  }
}

// optional .com.laex.cg2d.model.CGBodyDef bodyDef = 8;
inline bool CGShape::has_bodydef() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CGShape::set_has_bodydef() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CGShape::clear_has_bodydef() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CGShape::clear_bodydef() {
  if (bodydef_ != NULL) bodydef_->::com::laex::cg2d::model::CGBodyDef::Clear();
  clear_has_bodydef();
}
inline const ::com::laex::cg2d::model::CGBodyDef& CGShape::bodydef() const {
  return bodydef_ != NULL ? *bodydef_ : *default_instance_->bodydef_;
}
inline ::com::laex::cg2d::model::CGBodyDef* CGShape::mutable_bodydef() {
  set_has_bodydef();
  if (bodydef_ == NULL) bodydef_ = new ::com::laex::cg2d::model::CGBodyDef;
  return bodydef_;
}
inline ::com::laex::cg2d::model::CGBodyDef* CGShape::release_bodydef() {
  clear_has_bodydef();
  ::com::laex::cg2d::model::CGBodyDef* temp = bodydef_;
  bodydef_ = NULL;
  return temp;
}
inline void CGShape::set_allocated_bodydef(::com::laex::cg2d::model::CGBodyDef* bodydef) {
  delete bodydef_;
  bodydef_ = bodydef;
  if (bodydef) {
    set_has_bodydef();
  } else {
    clear_has_bodydef();
  }
}

// optional .com.laex.cg2d.model.CGFixtureDef fixtureDef = 9;
inline bool CGShape::has_fixturedef() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CGShape::set_has_fixturedef() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CGShape::clear_has_fixturedef() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CGShape::clear_fixturedef() {
  if (fixturedef_ != NULL) fixturedef_->::com::laex::cg2d::model::CGFixtureDef::Clear();
  clear_has_fixturedef();
}
inline const ::com::laex::cg2d::model::CGFixtureDef& CGShape::fixturedef() const {
  return fixturedef_ != NULL ? *fixturedef_ : *default_instance_->fixturedef_;
}
inline ::com::laex::cg2d::model::CGFixtureDef* CGShape::mutable_fixturedef() {
  set_has_fixturedef();
  if (fixturedef_ == NULL) fixturedef_ = new ::com::laex::cg2d::model::CGFixtureDef;
  return fixturedef_;
}
inline ::com::laex::cg2d::model::CGFixtureDef* CGShape::release_fixturedef() {
  clear_has_fixturedef();
  ::com::laex::cg2d::model::CGFixtureDef* temp = fixturedef_;
  fixturedef_ = NULL;
  return temp;
}
inline void CGShape::set_allocated_fixturedef(::com::laex::cg2d::model::CGFixtureDef* fixturedef) {
  delete fixturedef_;
  fixturedef_ = fixturedef;
  if (fixturedef) {
    set_has_fixturedef();
  } else {
    clear_has_fixturedef();
  }
}

// repeated .com.laex.cg2d.model.CGJoint joints = 10;
inline int CGShape::joints_size() const {
  return joints_.size();
}
inline void CGShape::clear_joints() {
  joints_.Clear();
}
inline const ::com::laex::cg2d::model::CGJoint& CGShape::joints(int index) const {
  return joints_.Get(index);
}
inline ::com::laex::cg2d::model::CGJoint* CGShape::mutable_joints(int index) {
  return joints_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGJoint* CGShape::add_joints() {
  return joints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGJoint >&
CGShape::joints() const {
  return joints_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGJoint >*
CGShape::mutable_joints() {
  return &joints_;
}

// optional .com.laex.cg2d.model.CGResourceFile entityRefFile = 11;
inline bool CGShape::has_entityreffile() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CGShape::set_has_entityreffile() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CGShape::clear_has_entityreffile() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CGShape::clear_entityreffile() {
  if (entityreffile_ != NULL) entityreffile_->::com::laex::cg2d::model::CGResourceFile::Clear();
  clear_has_entityreffile();
}
inline const ::com::laex::cg2d::model::CGResourceFile& CGShape::entityreffile() const {
  return entityreffile_ != NULL ? *entityreffile_ : *default_instance_->entityreffile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGShape::mutable_entityreffile() {
  set_has_entityreffile();
  if (entityreffile_ == NULL) entityreffile_ = new ::com::laex::cg2d::model::CGResourceFile;
  return entityreffile_;
}
inline ::com::laex::cg2d::model::CGResourceFile* CGShape::release_entityreffile() {
  clear_has_entityreffile();
  ::com::laex::cg2d::model::CGResourceFile* temp = entityreffile_;
  entityreffile_ = NULL;
  return temp;
}
inline void CGShape::set_allocated_entityreffile(::com::laex::cg2d::model::CGResourceFile* entityreffile) {
  delete entityreffile_;
  entityreffile_ = entityreffile;
  if (entityreffile) {
    set_has_entityreffile();
  } else {
    clear_has_entityreffile();
  }
}

// -------------------------------------------------------------------

// CGLayer

// optional int32 id = 1;
inline bool CGLayer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGLayer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGLayer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGLayer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CGLayer::id() const {
  return id_;
}
inline void CGLayer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool CGLayer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGLayer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGLayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGLayer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CGLayer::name() const {
  return *name_;
}
inline void CGLayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGLayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGLayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGLayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CGLayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGLayer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool visible = 3;
inline bool CGLayer::has_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGLayer::set_has_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGLayer::clear_has_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGLayer::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool CGLayer::visible() const {
  return visible_;
}
inline void CGLayer::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional bool locked = 4;
inline bool CGLayer::has_locked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGLayer::set_has_locked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGLayer::clear_has_locked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGLayer::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool CGLayer::locked() const {
  return locked_;
}
inline void CGLayer::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// repeated .com.laex.cg2d.model.CGShape shape = 5;
inline int CGLayer::shape_size() const {
  return shape_.size();
}
inline void CGLayer::clear_shape() {
  shape_.Clear();
}
inline const ::com::laex::cg2d::model::CGShape& CGLayer::shape(int index) const {
  return shape_.Get(index);
}
inline ::com::laex::cg2d::model::CGShape* CGLayer::mutable_shape(int index) {
  return shape_.Mutable(index);
}
inline ::com::laex::cg2d::model::CGShape* CGLayer::add_shape() {
  return shape_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGShape >&
CGLayer::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::laex::cg2d::model::CGShape >*
CGLayer::mutable_shape() {
  return &shape_;
}

// -------------------------------------------------------------------

// CGScreenPreferences_CGDebugDrawPreferences

// optional bool drawBodies = 1;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawbodies() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawbodies() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawbodies() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawbodies() {
  drawbodies_ = false;
  clear_has_drawbodies();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawbodies() const {
  return drawbodies_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawbodies(bool value) {
  set_has_drawbodies();
  drawbodies_ = value;
}

// optional bool drawJoints = 2;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawjoints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawjoints() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawjoints() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawjoints() {
  drawjoints_ = false;
  clear_has_drawjoints();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawjoints() const {
  return drawjoints_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawjoints(bool value) {
  set_has_drawjoints();
  drawjoints_ = value;
}

// optional bool drawAABB = 3;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawaabb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawaabb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawaabb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawaabb() {
  drawaabb_ = false;
  clear_has_drawaabb();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawaabb() const {
  return drawaabb_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawaabb(bool value) {
  set_has_drawaabb();
  drawaabb_ = value;
}

// optional bool drawInactiveBodies = 4;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawinactivebodies() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawinactivebodies() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawinactivebodies() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawinactivebodies() {
  drawinactivebodies_ = false;
  clear_has_drawinactivebodies();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawinactivebodies() const {
  return drawinactivebodies_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawinactivebodies(bool value) {
  set_has_drawinactivebodies();
  drawinactivebodies_ = value;
}

// optional bool installMouseJoint = 5;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_installmousejoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_installmousejoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_installmousejoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_installmousejoint() {
  installmousejoint_ = false;
  clear_has_installmousejoint();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::installmousejoint() const {
  return installmousejoint_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_installmousejoint(bool value) {
  set_has_installmousejoint();
  installmousejoint_ = value;
}

// optional bool drawDebugData = 6;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawdebugdata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawdebugdata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawdebugdata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawdebugdata() {
  drawdebugdata_ = false;
  clear_has_drawdebugdata();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawdebugdata() const {
  return drawdebugdata_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawdebugdata(bool value) {
  set_has_drawdebugdata();
  drawdebugdata_ = value;
}

// optional bool drawEntities = 7;
inline bool CGScreenPreferences_CGDebugDrawPreferences::has_drawentities() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_has_drawentities() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_has_drawentities() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::clear_drawentities() {
  drawentities_ = false;
  clear_has_drawentities();
}
inline bool CGScreenPreferences_CGDebugDrawPreferences::drawentities() const {
  return drawentities_;
}
inline void CGScreenPreferences_CGDebugDrawPreferences::set_drawentities(bool value) {
  set_has_drawentities();
  drawentities_ = value;
}

// -------------------------------------------------------------------

// CGScreenPreferences_CGWorldPreferences

// optional int32 ptmRatio = 1;
inline bool CGScreenPreferences_CGWorldPreferences::has_ptmratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_ptmratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_ptmratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_ptmratio() {
  ptmratio_ = 0;
  clear_has_ptmratio();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGWorldPreferences::ptmratio() const {
  return ptmratio_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_ptmratio(::google::protobuf::int32 value) {
  set_has_ptmratio();
  ptmratio_ = value;
}

// optional int32 velocityIterations = 2;
inline bool CGScreenPreferences_CGWorldPreferences::has_velocityiterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_velocityiterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_velocityiterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_velocityiterations() {
  velocityiterations_ = 0;
  clear_has_velocityiterations();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGWorldPreferences::velocityiterations() const {
  return velocityiterations_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_velocityiterations(::google::protobuf::int32 value) {
  set_has_velocityiterations();
  velocityiterations_ = value;
}

// optional int32 positionIterations = 3;
inline bool CGScreenPreferences_CGWorldPreferences::has_positioniterations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_positioniterations() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_positioniterations() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_positioniterations() {
  positioniterations_ = 0;
  clear_has_positioniterations();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGWorldPreferences::positioniterations() const {
  return positioniterations_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_positioniterations(::google::protobuf::int32 value) {
  set_has_positioniterations();
  positioniterations_ = value;
}

// optional float timeStep = 4;
inline bool CGScreenPreferences_CGWorldPreferences::has_timestep() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_timestep() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_timestep() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_timestep() {
  timestep_ = 0;
  clear_has_timestep();
}
inline float CGScreenPreferences_CGWorldPreferences::timestep() const {
  return timestep_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_timestep(float value) {
  set_has_timestep();
  timestep_ = value;
}

// optional float gravityX = 5;
inline bool CGScreenPreferences_CGWorldPreferences::has_gravityx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_gravityx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_gravityx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_gravityx() {
  gravityx_ = 0;
  clear_has_gravityx();
}
inline float CGScreenPreferences_CGWorldPreferences::gravityx() const {
  return gravityx_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_gravityx(float value) {
  set_has_gravityx();
  gravityx_ = value;
}

// optional float gravityY = 6;
inline bool CGScreenPreferences_CGWorldPreferences::has_gravityy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CGScreenPreferences_CGWorldPreferences::set_has_gravityy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_has_gravityy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CGScreenPreferences_CGWorldPreferences::clear_gravityy() {
  gravityy_ = 0;
  clear_has_gravityy();
}
inline float CGScreenPreferences_CGWorldPreferences::gravityy() const {
  return gravityy_;
}
inline void CGScreenPreferences_CGWorldPreferences::set_gravityy(float value) {
  set_has_gravityy();
  gravityy_ = value;
}

// -------------------------------------------------------------------

// CGScreenPreferences_CGCardPreferences

// optional int32 cardNoX = 1;
inline bool CGScreenPreferences_CGCardPreferences::has_cardnox() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGScreenPreferences_CGCardPreferences::set_has_cardnox() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_has_cardnox() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_cardnox() {
  cardnox_ = 0;
  clear_has_cardnox();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGCardPreferences::cardnox() const {
  return cardnox_;
}
inline void CGScreenPreferences_CGCardPreferences::set_cardnox(::google::protobuf::int32 value) {
  set_has_cardnox();
  cardnox_ = value;
}

// optional int32 cardNoY = 2;
inline bool CGScreenPreferences_CGCardPreferences::has_cardnoy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGScreenPreferences_CGCardPreferences::set_has_cardnoy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_has_cardnoy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_cardnoy() {
  cardnoy_ = 0;
  clear_has_cardnoy();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGCardPreferences::cardnoy() const {
  return cardnoy_;
}
inline void CGScreenPreferences_CGCardPreferences::set_cardnoy(::google::protobuf::int32 value) {
  set_has_cardnoy();
  cardnoy_ = value;
}

// optional int32 cardWidth = 3;
inline bool CGScreenPreferences_CGCardPreferences::has_cardwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGScreenPreferences_CGCardPreferences::set_has_cardwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_has_cardwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_cardwidth() {
  cardwidth_ = 0;
  clear_has_cardwidth();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGCardPreferences::cardwidth() const {
  return cardwidth_;
}
inline void CGScreenPreferences_CGCardPreferences::set_cardwidth(::google::protobuf::int32 value) {
  set_has_cardwidth();
  cardwidth_ = value;
}

// optional int32 cardHeight = 4;
inline bool CGScreenPreferences_CGCardPreferences::has_cardheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGScreenPreferences_CGCardPreferences::set_has_cardheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_has_cardheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGScreenPreferences_CGCardPreferences::clear_cardheight() {
  cardheight_ = 0;
  clear_has_cardheight();
}
inline ::google::protobuf::int32 CGScreenPreferences_CGCardPreferences::cardheight() const {
  return cardheight_;
}
inline void CGScreenPreferences_CGCardPreferences::set_cardheight(::google::protobuf::int32 value) {
  set_has_cardheight();
  cardheight_ = value;
}

// -------------------------------------------------------------------

// CGScreenPreferences

// optional .com.laex.cg2d.model.CGScreenPreferences.CGDebugDrawPreferences debugDrawPrefs = 1;
inline bool CGScreenPreferences::has_debugdrawprefs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGScreenPreferences::set_has_debugdrawprefs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGScreenPreferences::clear_has_debugdrawprefs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGScreenPreferences::clear_debugdrawprefs() {
  if (debugdrawprefs_ != NULL) debugdrawprefs_->::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences::Clear();
  clear_has_debugdrawprefs();
}
inline const ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences& CGScreenPreferences::debugdrawprefs() const {
  return debugdrawprefs_ != NULL ? *debugdrawprefs_ : *default_instance_->debugdrawprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* CGScreenPreferences::mutable_debugdrawprefs() {
  set_has_debugdrawprefs();
  if (debugdrawprefs_ == NULL) debugdrawprefs_ = new ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences;
  return debugdrawprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* CGScreenPreferences::release_debugdrawprefs() {
  clear_has_debugdrawprefs();
  ::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* temp = debugdrawprefs_;
  debugdrawprefs_ = NULL;
  return temp;
}
inline void CGScreenPreferences::set_allocated_debugdrawprefs(::com::laex::cg2d::model::CGScreenPreferences_CGDebugDrawPreferences* debugdrawprefs) {
  delete debugdrawprefs_;
  debugdrawprefs_ = debugdrawprefs;
  if (debugdrawprefs) {
    set_has_debugdrawprefs();
  } else {
    clear_has_debugdrawprefs();
  }
}

// optional .com.laex.cg2d.model.CGScreenPreferences.CGWorldPreferences worldPrefs = 2;
inline bool CGScreenPreferences::has_worldprefs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGScreenPreferences::set_has_worldprefs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGScreenPreferences::clear_has_worldprefs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGScreenPreferences::clear_worldprefs() {
  if (worldprefs_ != NULL) worldprefs_->::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences::Clear();
  clear_has_worldprefs();
}
inline const ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences& CGScreenPreferences::worldprefs() const {
  return worldprefs_ != NULL ? *worldprefs_ : *default_instance_->worldprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* CGScreenPreferences::mutable_worldprefs() {
  set_has_worldprefs();
  if (worldprefs_ == NULL) worldprefs_ = new ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences;
  return worldprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* CGScreenPreferences::release_worldprefs() {
  clear_has_worldprefs();
  ::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* temp = worldprefs_;
  worldprefs_ = NULL;
  return temp;
}
inline void CGScreenPreferences::set_allocated_worldprefs(::com::laex::cg2d::model::CGScreenPreferences_CGWorldPreferences* worldprefs) {
  delete worldprefs_;
  worldprefs_ = worldprefs;
  if (worldprefs) {
    set_has_worldprefs();
  } else {
    clear_has_worldprefs();
  }
}

// optional .com.laex.cg2d.model.CGScreenPreferences.CGCardPreferences cardPrefs = 3;
inline bool CGScreenPreferences::has_cardprefs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGScreenPreferences::set_has_cardprefs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGScreenPreferences::clear_has_cardprefs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGScreenPreferences::clear_cardprefs() {
  if (cardprefs_ != NULL) cardprefs_->::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences::Clear();
  clear_has_cardprefs();
}
inline const ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences& CGScreenPreferences::cardprefs() const {
  return cardprefs_ != NULL ? *cardprefs_ : *default_instance_->cardprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* CGScreenPreferences::mutable_cardprefs() {
  set_has_cardprefs();
  if (cardprefs_ == NULL) cardprefs_ = new ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences;
  return cardprefs_;
}
inline ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* CGScreenPreferences::release_cardprefs() {
  clear_has_cardprefs();
  ::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* temp = cardprefs_;
  cardprefs_ = NULL;
  return temp;
}
inline void CGScreenPreferences::set_allocated_cardprefs(::com::laex::cg2d::model::CGScreenPreferences_CGCardPreferences* cardprefs) {
  delete cardprefs_;
  cardprefs_ = cardprefs;
  if (cardprefs) {
    set_has_cardprefs();
  } else {
    clear_has_cardprefs();
  }
}

// optional .com.laex.cg2d.model.CGColor backgroundColor = 4;
inline bool CGScreenPreferences::has_backgroundcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CGScreenPreferences::set_has_backgroundcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CGScreenPreferences::clear_has_backgroundcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CGScreenPreferences::clear_backgroundcolor() {
  if (backgroundcolor_ != NULL) backgroundcolor_->::com::laex::cg2d::model::CGColor::Clear();
  clear_has_backgroundcolor();
}
inline const ::com::laex::cg2d::model::CGColor& CGScreenPreferences::backgroundcolor() const {
  return backgroundcolor_ != NULL ? *backgroundcolor_ : *default_instance_->backgroundcolor_;
}
inline ::com::laex::cg2d::model::CGColor* CGScreenPreferences::mutable_backgroundcolor() {
  set_has_backgroundcolor();
  if (backgroundcolor_ == NULL) backgroundcolor_ = new ::com::laex::cg2d::model::CGColor;
  return backgroundcolor_;
}
inline ::com::laex::cg2d::model::CGColor* CGScreenPreferences::release_backgroundcolor() {
  clear_has_backgroundcolor();
  ::com::laex::cg2d::model::CGColor* temp = backgroundcolor_;
  backgroundcolor_ = NULL;
  return temp;
}
inline void CGScreenPreferences::set_allocated_backgroundcolor(::com::laex::cg2d::model::CGColor* backgroundcolor) {
  delete backgroundcolor_;
  backgroundcolor_ = backgroundcolor;
  if (backgroundcolor) {
    set_has_backgroundcolor();
  } else {
    clear_has_backgroundcolor();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace cg2d
}  // namespace laex
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::laex::cg2d::model::CGJointType>() {
  return ::com::laex::cg2d::model::CGJointType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::laex::cg2d::model::CGEntityCollisionType>() {
  return ::com::laex::cg2d::model::CGEntityCollisionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::laex::cg2d::model::CGBodyType>() {
  return ::com::laex::cg2d::model::CGBodyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::laex::cg2d::model::CGEditorShapeType>() {
  return ::com::laex::cg2d::model::CGEditorShapeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_com_2flaex_2fcg2d_2fmodel_2fScreenModel_2eproto__INCLUDED
